/* $Id: SWSexParser.ypp,v 1.2 2008-10-24 10:57:32 eric Exp $ -*- mode: c++ -*- */
/** \file SWSexParser.yy Contains the Bison parser source */

/*** yacc/bison Declarations ***/

/* Require bison 2.3 or later */
%require "2.3"

/* add debug output code to generated parser. disable this for release
 * versions. */
%debug

/* start symbol is named "start" */
%start SWSexDoc

/* write out a header file containing the token defines */
%defines

/* use newer C++ skeleton file */
%skeleton "lalr1.cc"

/* namespace to enclose parser in */
%name-prefix="w3c_sw"

/* set the parser's class identifier */
%define "parser_class_name" "SWSexParser"

/* keep track of the current position within the input */
%locations
%initial-action
{
    // initialize the initial location object
    @$.begin.filename = @$.end.filename = &driver.streamname;
    driver.yylloc = &@$;
};

/* The driver is passed by reference to the parser and to the scanner. This
 * provides a simple but effective pure interface, not relying on global
 * variables. */
%parse-param { class SWSexDriver& driver }

/* verbose error messages */
%error-verbose

// %{ //  ##bison1
%code requires { // ##bison2
/* Bison seems to test inclusion with PARSER_HEADER_H, rather than something
 * which varies by parser_class_name . Overriding with define specific to
 * this parser.
 */
#endif /* !PARSER_HEADER_H */
#ifndef SWSEX_PARSER_HPP
#define SWSEX_PARSER_HPP

#include "SWObjects.hpp"
#include "RdfDB.hpp"
#include "ParserCommon.hpp"
#include "SWSexSchema.hpp"
#include <stack>

namespace w3c_sw {

class SWSexDriver : public YaccDataDriver {
    location* yylloc; // can't move up into YaccDriver 'cause location.hh hasn't been included yet.
    friend class SWSexParser;
protected:
    SWSexSchema* curSchema;
    SWSexSchema::SetRule* curSetRule;
    SWSexSchema::AtomicRule::NameClass* curNameClass;
    SWSexSchema::RulePattern* curRulePattern;
    std::vector<const TTerm*>* curTTerms;
public:
    void setSchema (SWSexSchema* schema) { curSchema = schema; }
    static size_t DefaultAbortErrorCount;

    SWSexDriver (std::string baseURI, AtomFactory* atomFactory, size_t abortErrorCount = DefaultAbortErrorCount)
	: YaccDataDriver(baseURI, atomFactory, abortErrorCount)
    {  }

    SWSexSchema* parse(IStreamContext& in);
    SWSexSchema* parse(IStreamContext& in, SWSexSchema* schema);
    SWSexSchema* parse(std::string swsexStr, SWSexSchema* schema);


    /** Pointer to the current lexer instance, this is used to connect the
     * parser to the scanner. It is used in the yylex macro. */
    class SWSexScanner* lexer;
};

} // namespace w3c_sw

// %} // ##bison1
} // ##bison2

 /*** BEGIN SWSex language tokens. ***/

%union {
    struct {std::string* label; std::string* text;} p_CODE;
    int p_int;
    SWSexSchema::AtomicRule::NameClass* p_nameClass;
    bool p_bool;
    SWSexSchema::SetRule* p_setRule;
    SWSexSchema::RulePattern* p_rulePattern;
    SWSexSchema::RuleActions* p_ruleActions;
    SWSexSchema::AtomicRule::Value* p_value;
    SWSexSchema::AtomicRule::ValueSet* p_valueSet;
    struct {unsigned min; unsigned max;} p_RepeatRange;

    struct {const TTerm* subject; const TTerm* predicate;} p_SubjectPredicatePair;
    struct {const URI* uri; LANGTAG* langtag;} p_uri_or_langtag;

    /* Terminals */
    LANGTAG* p_LANGTAG;

    std::string* p_string;

    const NumericRDFLiteral* p_NumericRDFLiteral;
    const BooleanRDFLiteral* p_BooleanRDFLiteral;

    /* Productions */
    BasicGraphPattern* p_DefaultGraphPattern;
    const TTerm* p_TTerm;
    const URI* p_URI;
    ProductionVector<URI*>* p_URIs;
    const RDFLiteral* p_RDFLiteral;
    const BNode* p_BNode;

}

%{
#include "../SWSexScanner.hpp"
%}
%token			__EOF__	     0	"end of file"
/* START TokenBlock */
/* Terminals */

%token BASE PREFIX SPARQL_BASE RDF_TYPE SPARQL_PREFIX GT_LPAREN GT_RPAREN GT_DOT
       GT_COMMA GT_SEMI GT_LBRACKET GT_RBRACKET GT_DTYPE
       GT_AT GT_CARROT GT_EQUAL GT_LCURLEY GT_MINUS GT_NOT GT_OPT GT_PIPE GT_PLUS GT_RCURLEY GT_TIMES IT_start
%token <p_CODE> CODE
%token <p_TTerm> IT_true IT_false BLANK_NODE_LABEL ANON
%token <p_NumericRDFLiteral> INTEGER DECIMAL DOUBLE
// deepest typing for these tokens:
// %token <p_BooleanRDFLiteral> IT_true IT_false
// %token <p_NumericRDFLiteral> INTEGER DECIMAL DOUBLE
// %token <p_BNode> BLANK_NODE_LABEL ANON
%token <p_string> STRING_LITERAL1 STRING_LITERAL2 STRING_LITERAL_LONG1 STRING_LITERAL_LONG2
%token <p_URI> PNAME_NS PNAME_LN IRIREF
%token <p_LANGTAG> LANGTAG

 // !!NEW tokens
%type <p_TTerm> _O_Qlabel_E_Or_QtypeSpec_E_S_QCODE_E_Star_C label  object RDFLiteral literal NumericLiteral BooleanLiteral BlankNode
 //%type <p_TTerms> _Qobject_E_Plus valueSet
%type <p_int> _QINTEGER_E_Opt _O_QGT_COMMA_E_S_QINTEGER_E_Opt_C _Q_O_QGT_COMMA_E_S_QINTEGER_E_Opt_C_E_Opt
%type <p_nameClass> nameClass _O_Qiri_E_Or_QGT_TIMES_E_Or_Qiri_E_S_QGT_TIMES_E_C
%type <p_bool> _QGT_CARROT_E_Opt _QGT_NOT_E_Opt
%type <p_rulePattern> typeSpec OrExpression _O_QGT_PIPE_E_S_QAndExpression_E_C AndExpression _O_QGT_COMMA_E_S_QUnaryExpression_E_C UnaryExpression _O_Qarc_E_Or_QGT_LPAREN_E_S_QOrExpression_E_S_QGT_RPAREN_E_S_QCODE_E_Star_C arc valueSpec
%type <p_ruleActions> _QCODE_E_Star
%type <p_value> _O_QGT_AT_E_S_Qlabel_E_Or_QtypeSpec_E_Or_QvalueSet_E_Or_Qobject_E_Or_QGT_MINUS_E_C
%type <p_RepeatRange> _QrepeatCount_E_Opt repeatCount

%type <p_URI> iri PrefixedName
// deepest typing for these productions:
// %type <p_RDFLiteral> RDFLiteral literal
// %type <p_NumericRDFLiteral> NumericLiteral
// %type <p_BooleanRDFLiteral> BooleanLiteral
%type <p_string> String
%type <p_uri_or_langtag> _O_QLANGTAG_E_Or_QGT_DTYPE_E_S_Qiri_E_C
                       _Q_O_QLANGTAG_E_Or_QGT_DTYPE_E_S_Qiri_E_C_E_Opt

/* END TokenBlock */

//%destructor { delete $$; } BlankNode

 /*** END SWSex language tokens. ***/

%{
#include "../SWSexScanner.hpp"

/* this "connects" the bison parser in the driver to the flex scanner class
 * object. it defines the yylex() function call to pull the next token from the
 * current lexer object of the driver context. */
#undef yylex
#define yylex driver.lexer->lexWrapper
%}

%% /*** Grammar Rules ***/

 /*** BEGIN SWSex language structure. ***/
SWSexDoc:
    // statement*
    _Qstatement_E_Star	
;

_Qstatement_E_Star:
    
  | _Qstatement_E_Star statement	
;

statement:
    directive	
  | shape	
;

directive:
    sparqlPrefix	
  | sparqlBase	
  | IT_start GT_EQUAL _O_Qlabel_E_Or_QtypeSpec_E_S_QCODE_E_Star_C	{
	driver.curSchema->start = $3;
    }
;

_QCODE_E_Star:
    {
	$$ = NULL;
    }
  | _QCODE_E_Star CODE	{
	$$ = ($1 == NULL)
	    ? new SWSexSchema::RuleActions(driver.curRulePattern)
	    : $1;
	$$->codeMap.insert(std::make_pair(*$2.label, *$2.text));
	delete $2.label;
	delete $2.text;
    }
;

_O_Qlabel_E_Or_QtypeSpec_E_S_QCODE_E_Star_C:
    label	
    | typeSpec {
	driver.curRulePattern = $1;
      } _QCODE_E_Star	{
	  driver.curRulePattern = NULL;
	  $$ = driver.createBNode();
	  driver.curSchema->ruleMap.insert(std::make_pair($$, $3 == NULL ? $1 : $3));
      }
;

sparqlPrefix:
    SPARQL_PREFIX {
	driver.ignorePrefix(true);
      } PNAME_NS {
	  driver.ignorePrefix(false);
      } IRIREF	{
	  std::string prefix($3->getLexicalValue());
	  driver.addPrefix(prefix.substr(0, prefix.length()-1), $5);
      }
;

sparqlBase:
    SPARQL_BASE IRIREF	{
	driver.setBase($2->getLexicalValue());
    }
;

shape:
    label typeSpec {
	driver.curRulePattern = $2;
      } _QCODE_E_Star	{
	  driver.curRulePattern = NULL;
	  driver.curSchema->ruleMap.insert(std::make_pair($1, $4 == NULL ? $2 : $4));
      }
;

typeSpec:
    GT_LCURLEY {
	$<p_nameClass>$ = driver.curNameClass;
	driver.curNameClass = NULL;
      } {
	  $<p_rulePattern>$ = driver.curRulePattern;
	  driver.curRulePattern = NULL;
      } OrExpression GT_RCURLEY	{
	  driver.curRulePattern = $<p_rulePattern>3;
	  driver.curNameClass = $<p_nameClass>2;
	  $$ = $4;
      }
;

OrExpression:
    {
	$<p_setRule>$ = driver.curSetRule;
	driver.curSetRule = NULL;
    } AndExpression _Q_O_QGT_PIPE_E_S_QAndExpression_E_C_E_Star	{
	if (driver.curSetRule == NULL)
	    $$ = $2;
	else {
	    driver.curSetRule->rules.insert(driver.curSetRule->rules.begin(), $2);
	    $$ = driver.curSetRule;
	}
	driver.curSetRule = $<p_setRule>1;
    }
;

_O_QGT_PIPE_E_S_QAndExpression_E_C:
    GT_PIPE AndExpression	{
	$$ = $2;
    }
;

_Q_O_QGT_PIPE_E_S_QAndExpression_E_C_E_Star:
    
  | _Q_O_QGT_PIPE_E_S_QAndExpression_E_C_E_Star _O_QGT_PIPE_E_S_QAndExpression_E_C	{
	if (driver.curSetRule == NULL)
	    driver.curSetRule = new SWSexSchema::OrRule();
	driver.curSetRule->rules.push_back($2);
    }
;

AndExpression:
    {
	$<p_setRule>$ = driver.curSetRule;
	driver.curSetRule = NULL;
    } UnaryExpression _Q_O_QGT_COMMA_E_S_QUnaryExpression_E_C_E_Star	{
	if (driver.curSetRule == NULL)
	    $$ = $2;
	else {
	    driver.curSetRule->rules.insert(driver.curSetRule->rules.begin(), $2);
	    $$ = driver.curSetRule;
	}
	driver.curSetRule = $<p_setRule>1;
    }
;

_O_QGT_COMMA_E_S_QUnaryExpression_E_C:
    GT_COMMA UnaryExpression	{
	$$ = $2;
    }
;

_Q_O_QGT_COMMA_E_S_QUnaryExpression_E_C_E_Star:
    
  | _Q_O_QGT_COMMA_E_S_QUnaryExpression_E_C_E_Star _O_QGT_COMMA_E_S_QUnaryExpression_E_C	{
	if (driver.curSetRule == NULL)
	    driver.curSetRule = new SWSexSchema::AndRule();
	driver.curSetRule->rules.push_back($2);
    }
;

UnaryExpression:
    _QGT_NOT_E_Opt _O_Qarc_E_Or_QGT_LPAREN_E_S_QOrExpression_E_S_QGT_RPAREN_E_S_QCODE_E_Star_C	{
	$$ = $1 ? new SWSexSchema::NegatedRule($2) : $2;
    }
;

_QGT_NOT_E_Opt:
    {
	$$ = false;
    }
  | GT_NOT	{
      $$ = true;
    }
;

_O_Qarc_E_Or_QGT_LPAREN_E_S_QOrExpression_E_S_QGT_RPAREN_E_S_QCODE_E_Star_C:
    arc	
  | GT_LPAREN OrExpression GT_RPAREN {
	driver.curRulePattern = $2;
      } _QCODE_E_Star	{
	  driver.curRulePattern = NULL;
	  $$ = $5 == NULL ? $2 : $5;
      }
;

arc:
    nameClass {
	// pass down the nameClass 'cause we need valueSpec's CODE* to be able
	// to make a AtomicRule and potentially wrap it with RuleActions.
	driver.curNameClass = $1;
    } valueSpec	{
	driver.curNameClass = NULL;
	$$ = $3;
    }
;

label:
    iri	{
	$$ = $1;
    }
  | BlankNode	{
	$$ = $1;
    }
;

nameClass:
    _QGT_CARROT_E_Opt _O_Qiri_E_Or_QGT_TIMES_E_Or_Qiri_E_S_QGT_TIMES_E_C	{
	$2->reverse = $1;
	$$ = $2;
    }
;

_QGT_CARROT_E_Opt:
    {
	$$ = false;
    }
  | GT_CARROT	{
	$$ = true;
    }
;

_O_Qiri_E_Or_QGT_TIMES_E_Or_Qiri_E_S_QGT_TIMES_E_C:
    iri	{
	$$ = new SWSexSchema::AtomicRule::NameTerm($1);
    }
  | GT_TIMES	{
	$$ = new SWSexSchema::AtomicRule::NameAll();
    }
  | iri GT_TIMES	{
	$$ = new SWSexSchema::AtomicRule::NamePattern($1);
    }
;

valueSpec:
    _O_QGT_AT_E_S_Qlabel_E_Or_QtypeSpec_E_Or_QvalueSet_E_Or_Qobject_E_Or_QGT_MINUS_E_C _QrepeatCount_E_Opt {
	driver.curRulePattern = new SWSexSchema::AtomicRule(driver.curNameClass, $1, $2.min, $2.max);
      } _QCODE_E_Star	{
	  $$ = $4 == NULL ? driver.curRulePattern : $4;
	  driver.curRulePattern = NULL;
      }
;

_O_QGT_AT_E_S_Qlabel_E_Or_QtypeSpec_E_Or_QvalueSet_E_Or_Qobject_E_Or_QGT_MINUS_E_C:
    GT_AT label	{
	$$ = new SWSexSchema::AtomicRule::ValueReference($2);
    }
  | typeSpec	{
	const TTerm* b = driver.createBNode();
	driver.curSchema->ruleMap.insert(std::make_pair(b, $1));
	$$ = new SWSexSchema::AtomicRule::ValueReference(b);
    }
  | {
	SWSexSchema::AtomicRule::ValueSet* t = new SWSexSchema::AtomicRule::ValueSet();
	$<p_valueSet>$  = t;
	driver.curTTerms = &t->tterms;
      } valueSet	{
	  $$ = $<p_valueSet>1;
      }
  | object	{
	$$ = new SWSexSchema::AtomicRule::ValueSimple($1);
    }
  | GT_MINUS	{
	$$ = new SWSexSchema::AtomicRule::ValueAny();
    }
;

_QrepeatCount_E_Opt:
    {
	$$.min = 1;
	$$.max = 1;
    }
  | repeatCount	
;

repeatCount:
    GT_TIMES	{
	$$.min = 0;
	$$.max = SWSexSchema::AtomicRule::Unlimited;
    }
  | GT_PLUS	{
	$$.min = 1;
	$$.max = SWSexSchema::AtomicRule::Unlimited;
    }
  | GT_OPT	{
	$$.min = 0;
	$$.max = 1;
    }
  | GT_LCURLEY INTEGER _Q_O_QGT_COMMA_E_S_QINTEGER_E_Opt_C_E_Opt GT_RCURLEY	{
	$$.min = $2->getInt();
	$$.max = $3;
    }
;

_QINTEGER_E_Opt:
    {
	$$ = SWSexSchema::AtomicRule::Unlimited;
    }
  | INTEGER	{
	$$ = $1->getInt();
    }
;

_O_QGT_COMMA_E_S_QINTEGER_E_Opt_C:
    GT_COMMA _QINTEGER_E_Opt	{
	$$ = $2;
    }
;

_Q_O_QGT_COMMA_E_S_QINTEGER_E_Opt_C_E_Opt:
    {
	$$ = SWSexSchema::AtomicRule::Unlimited;
    }
  | _O_QGT_COMMA_E_S_QINTEGER_E_Opt_C	
;

valueSet:
    GT_LPAREN _Qobject_E_Plus GT_RPAREN	
;

_Qobject_E_Plus:
    object	{
	driver.curTTerms->push_back($1);
    }
  | _Qobject_E_Plus object	{
	driver.curTTerms->push_back($2);
    }
;

object:
    iri	{
	$$ = $1;
    }
  | BlankNode	{
	$$ = $1;
    }
  | literal	{
	$$ = $1;
    }
;

literal:
    RDFLiteral	
  | NumericLiteral	// { $$ = $1; }
  | BooleanLiteral	// { $$ = $1; }
;

NumericLiteral:
    INTEGER	{
	$$ = $1;
    }
  | DECIMAL	{
	$$ = $1;
    }
  | DOUBLE	{
	$$ = $1;
    }
;

RDFLiteral:
    // String ( LANGTAG | ( '^^' iri ) )?
    String _Q_O_QLANGTAG_E_Or_QGT_DTYPE_E_S_Qiri_E_C_E_Opt	{
	$$ = driver.getRDFLiteral(*$1, $2.uri, $2.langtag);
	delete $1;
    }
;

// LANGTAG | ( '^^' iri )
_O_QLANGTAG_E_Or_QGT_DTYPE_E_S_Qiri_E_C:
    LANGTAG	{
	$$.uri = NULL;
	$$.langtag = $1;
    }
// '^^' iri
  | GT_DTYPE iri	{
	$$.uri = $2;
	$$.langtag = NULL;
    }
;

// ( LANGTAG | ( '^^' iri ) )?
_Q_O_QLANGTAG_E_Or_QGT_DTYPE_E_S_Qiri_E_C_E_Opt:
    {
	$$.uri = NULL;
	$$.langtag = NULL;
    }
  | _O_QLANGTAG_E_Or_QGT_DTYPE_E_S_Qiri_E_C	
;

BooleanLiteral:
    IT_true	
  | IT_false	
;

String:
    STRING_LITERAL1	
  | STRING_LITERAL2	
  | STRING_LITERAL_LONG1	
  | STRING_LITERAL_LONG2	
;

iri:
    IRIREF	
  | PrefixedName	
;

PrefixedName:
    PNAME_LN	
  | PNAME_NS	
;

BlankNode:
    BLANK_NODE_LABEL	
  | ANON	
;

 /*** END SWSex language structure. ***/

%% /*** Additional Code ***/

void w3c_sw::SWSexParser::error(const SWSexParser::location_type& l,
			    const std::string& m)
{
    std::string s = m;
    _SUBS(s, "GT_DOT", "'.'");
    _SUBS(s, "GT_SEMI", "';'");
    _SUBS(s, "GT_LBRACKET", "'['");
    _SUBS(s, "GT_RBRACKET", "']'");
    _SUBS(s, "GT_LPAREN", "'('");
    _SUBS(s, "GT_RPAREN", "')'");
    _SUBS(s, "GT_DTYPE", "'^^'");
    _SUBS(s, "IT_true", "boolean true");
    _SUBS(s, "IT_false", "boolean false");
    _SUBS(s, "SPARQL_PREFIX", "PREFIX");
    _SUBS(s, "SPARQL_BASE", "BASE");
    _SUBS(s, "BASE", "@base");
    _SUBS(s, "PREFIX", "@prefix");
    _SUBS(s, "RDF_TYPE", "keyword 'a'");
    _SUBS(s, "IRIREF", "IRI");
    _SUBS(s, "PNAME_NS", "namespace prefix");
    _SUBS(s, "PNAME_LN", "local name");
    _SUBS(s, "BLANK_NODE_LABEL", "blank node label");
    _SUBS(s, "LANGTAG", "language tag");
    _SUBS(s, "INTEGER", "integer");
    _SUBS(s, "DECIMAL", "decimal");
    _SUBS(s, "DOUBLE", "double");
    _SUBS(s, "STRING_LITERAL1", "'string'");
    _SUBS(s, "STRING_LITERAL2", "\"string\"");
    _SUBS(s, "STRING_LITERAL_LONG1", "'''string'''");
    _SUBS(s, "STRING_LITERAL_LONG2", "\"\"\"string\"\"\"");
    _SUBS(s, "ANON", "anonymous blank node");
    driver.error(l, s);
}

/* START Driver (@@ stand-alone would allow it to be shared with other parsers */

namespace w3c_sw {

size_t SWSexDriver::DefaultAbortErrorCount = 100;

SWSexSchema* SWSexDriver::parse (IStreamContext& in) {
    reset();
    streamname = in.nameStr;
    // clear prefixes for nth run but keep them around for e.g. serialization.
    clearPrefixes();

    SWSexScanner scanner(this, in.p);
    scanner.set_debug(trace_scanning);
    this->lexer = &scanner;

    SWSexParser parser(*this);
    parser.set_debug_level(trace_parsing);
    parser.parse();
    checkErrors();
    return curSchema;
}

SWSexSchema* SWSexDriver::parse (IStreamContext& in, SWSexSchema* schema) {
    setSchema(schema);
    return parse(in);
}

SWSexSchema* SWSexDriver::parse (std::string swsexStr, SWSexSchema* schema) {
    IStreamContext in(swsexStr.c_str(), IStreamContext::STRING);
    setSchema(schema);
    return parse(in);
}

} // namespace w3c_sw

/* END Driver */


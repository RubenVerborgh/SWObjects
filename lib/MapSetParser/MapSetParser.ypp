/* $Id: MapSetParser.ypp,v 1.3 2008-11-13 19:18:01 eric Exp $ -*- mode: c++ -*- */
/** \file MapSetParser.yy Contains the Bison parser source */

/*** yacc/bison Declarations ***/

/* Require bison 2.3 or later */
%require "2.3"

/* add debug output code to generated parser. disable this for release
 * versions. */
%debug

/* start symbol is named "start" */
%start MapSet

/* write out a header file containing the token defines */
%defines

/* use newer C++ skeleton file */
%skeleton "lalr1.cc"

/* namespace to enclose parser in */
%name-prefix="w3c_sw"

/* set the parser's class identifier */
%define "parser_class_name" "MapSetParser"

/* keep track of the current position within the input */
%locations
%initial-action
{
    // initialize the initial location object
    @$.begin.filename = @$.end.filename = &driver.streamname;
};

/* The driver is passed by reference to the parser and to the scanner. This
 * provides a simple but effective pure interface, not relying on global
 * variables. */
%parse-param { class MapSetDriver& driver }

/* verbose error messages */
%error-verbose

%{ /*** C/C++ Declarations ***/
/* Bison seems to test inclusion with PARSER_HEADER_H, rather than something
 * which varies by parser_class_name . Overriding with define specific to
 * this parser.
 */
#endif /* !PARSER_HEADER_H */
#ifndef MAPSET_PARSER_HPP
#define MAPSET_PARSER_HPP

#include "SWObjects.hpp"
#include "ParserCommon.hpp"
#include "QueryMapper.hpp"

#include <stack>
namespace w3c_sw {

class MapSetScanner;

/** The Driver class brings together all components. It creates an instance of
 * the MapSetParser and MapSetScanner classes and connects them. Then the input stream is
 * fed into the scanner object and the parser gets it's token
 * sequence. Furthermore the driver object is available in the grammar rules as
 * a parameter. Therefore the driver class contains a reference to the
 * structure into which the parsed data is saved. */

class MapSetDriver : public Driver {
    friend class MapSetParser;
protected:
    const POS* curSubject;
    const POS* curPredicate;
    std::vector<BasicGraphPattern*> bgpStack;
    BasicGraphPattern* neededBGP; // set to NULL as soon as it's returned as $$ anywhere
    BindingClause* curBindingClause;
    Binding* curBinding;
    ProductionVector<const Expression*>* curExprList;
    std::stack<const POS*> curGraphNameStack;

    BasicGraphPattern* makeBasicGraphPattern ( ) {
	if (!bgpStack.back()) {
	    if (curGraphNameStack.empty())
		neededBGP = new DefaultGraphPattern();
	    else
		neededBGP = new NamedGraphPattern(curGraphNameStack.top());
	    bgpStack.back() = neededBGP;
	}
	return bgpStack.back();
    }

public:
    MapSetDriver(std::string baseURI, POSFactory* posFactory);
    ~MapSetDriver();

    virtual bool parse_stream(std::istream& in,
		      const std::string& sname = "stream input");

    /** Pointer to the current lexer instance, this is used to connect the
     * parser to the scanner. It is used in the yylex macro. */
    class MapSetScanner* lexer;

    /** Reference to the object created during parsing of the SPARQL stream. */
    Operation* root;
};

} // namespace w3c_sw

%}

 /*** BEGIN MapSet - Change the grammar's tokens below ***/

%union {
    void* p_void;
    struct {const POS* subject; const POS* predicate;} p_SubjectPredicatePair;
    struct {int limit; int offset;} p_LimitOffsetPair;
    struct {const URI* uri; LANGTAG* langtag;} p_uri_or_langtag;
    struct {Operation* operation; WhereClause* whereClause;} p_OperationWhereClausePair;
    s_OrderConditionPair p_OrderConditionPair;
    std::vector<s_OrderConditionPair>* p_OrderConditions;
    TableConjunction* p_TableConjunction;
    TableDisjunction* p_TableDisjunction;

    /* Terminals */
    LANGTAG* p_LANGTAG;

    std::string* p_string;

    const NumericRDFLiteral* p_NumericRDFLiteral;
    const BooleanRDFLiteral* p_BooleanRDFLiteral;

    /* Productions */
    Operation* p_Operation;
    const Variable* p_Variable;

    e_distinctness p_distinctness;
    e_listModifier p_listModifier;
    e_Silence p_Silence;
    POSList* p_POSList;
    VarSet* p_VarSet;
    ProductionVector<const DatasetClause*>* p_DatasetClauses;
    Construct* p_Construct;
    MapSet* p_MapSet;
    Ask* p_Ask;
    DatasetClause* p_DatasetClause;
    DefaultGraphClause* p_DefaultGraphClause;
    NamedGraphClause* p_NamedGraphClause;
    WhereClause* p_WhereClause;
    SolutionModifier* p_SolutionModifier;
    e_ASCorDESC p_e_ASCorDESC;
    BindingClause* p_BindingClause;
    ProductionVector<const Binding*>* p_Bindings;
    Binding* p_Binding;
    TableOperation* p_TableOperation;
    ProductionVector<const TableOperation*>* p_TableOperations;
    OptionalGraphPattern* p_OptionalGraphPattern;
    BasicGraphPattern* p_BasicGraphPattern;
    FilterHolder* p_FilterHolder;
    Filter* p_Filter;
    FunctionCall* p_FunctionCall;
    ArgList* p_ArgList;
    const POS* p_POS;
    ProductionVector<const POS*>* p_POSs;
    Expression* p_Expression;
    ProductionVector<const Expression*>* p_Expressions;
    BooleanComparator* p_BooleanComparator;
    const URI* p_URI;
    ProductionVector<const URI*>* p_URIs;
    const RDFLiteral* p_RDFLiteral;
    const BNode* p_BNode;

}

%{
#include "../MapSetScanner.hpp"
%}
%token			__EOF__	     0	"end of file"
/* START TokenBlock */
/* Terminals */
%token <p_void> IT_REWRITEVAR
%token <p_void> IT_SERVER
%token <p_void> IT_USER
%token <p_void> IT_PASSWORD
%token <p_void> IT_DATABASE
%token <p_void> IT_STEMURI
%token <p_void> IT_PRIMARYKEY
%token <p_void> IT_LABEL

%token <p_void> IT_REPLACE
%token <p_void> IT_WITH
%token <p_void> IT_DELETE
%token <p_void> IT_INSERT
%token <p_void> IT_GRAPH
%token <p_void> IT_LOAD
%token <p_void> IT_INTO
%token <p_void> IT_CLEAR
%token <p_void> IT_CREATE
%token <p_void> IT_SILENT
%token <p_void> IT_DROP

%token <p_void> IT_BASE
%token <p_void> IT_PREFIX
%token <p_void> IT_SELECT
%token <p_void> IT_DISTINCT
%token <p_void> IT_REDUCED
%token <p_void> GT_TIMES
%token <p_void> IT_CONSTRUCT
%token <p_void> IT_DESCRIBE
%token <p_void> IT_FROM
%token <p_void> IT_NAMED
%token <p_void> IT_ORDER
%token <p_void> IT_BY
%token <p_void> IT_ASC
%token <p_void> IT_DESC
%token <p_void> IT_LIMIT
%token <p_void> IT_OFFSET
%token <p_void> IT_BINDINGS
%token <p_void> IT_MEMBERS IT_STARTS IT_ENDS IT_ANY IT_UNORDERED
%token <p_void> GT_LCURLEY GT_RCURLEY IT_ASK IT_WHERE
%token <p_void> GT_LPAREN
%token <p_void> GT_RPAREN
%token <p_void> IT_NULL
%token <p_void> GT_DOT
%token <p_void> IT_OPTIONAL
%token <p_void> IT_UNION
%token <p_void> IT_FILTER
%token <p_void> GT_COMMA
%token <p_void> GT_SEMI
%token <p_void> IT_a
%token <p_void> GT_LBRACKET
%token <p_void> GT_RBRACKET
%token <p_void> GT_OR
%token <p_void> GT_AND
%token <p_void> GT_EQUAL
%token <p_void> GT_NEQUAL
%token <p_void> GT_LT
%token <p_void> GT_GT
%token <p_void> GT_LE
%token <p_void> GT_GE
%token <p_void> GT_PLUS
%token <p_void> GT_MINUS
%token <p_void> GT_DIVIDE
%token <p_void> GT_NOT
%token <p_void> IT_STR
%token <p_void> IT_LANG
%token <p_void> IT_LANGMATCHES
%token <p_void> IT_DATATYPE
%token <p_void> IT_BOUND
%token <p_void> IT_sameTerm
%token <p_void> IT_isIRI
%token <p_void> IT_isURI
%token <p_void> IT_isBLANK
%token <p_void> IT_isLITERAL
%token <p_void> IT_REGEX
%token <p_void> GT_DTYPE
%token <p_BooleanRDFLiteral> IT_true IT_false
%token <p_NumericRDFLiteral> INTEGER DECIMAL DOUBLE INTEGER_POSITIVE DECIMAL_POSITIVE DOUBLE_POSITIVE INTEGER_NEGATIVE DECIMAL_NEGATIVE DOUBLE_NEGATIVE
%token <p_string> STRING_LITERAL1 STRING_LITERAL2 STRING_LITERAL_LONG1 STRING_LITERAL_LONG2
%token <p_URI> IRI_REF PNAME_NS PNAME_LN
%token <p_BNode> BLANK_NODE_LABEL ANON
%token <p_Variable> VAR1 VAR2
%token <p_LANGTAG> LANGTAG
%token <p_NIL> NIL

/* Productions */
%type <p_Operation> MapSet

%type <p_listModifier> _O_QIT_MEMBERS_E_Or_QIT_STARTS_E_Or_QIT_ENDS_E_Or_QIT_ANY_E_Or_QIT_UNORDERED_E_C _Q_O_QIT_MEMBERS_E_Or_QIT_STARTS_E_Or_QIT_ENDS_E_Or_QIT_ANY_E_Or_QIT_UNORDERED_E_C_E_Opt
%type <p_POSList> _QVar_E_Plus
%type <p_DatasetClauses> _QDatasetClause_E_Star
%type <p_Construct> Construct
%type <p_POSs> _QGraphNode_E_Star _O_QGraphNode_E_S_QGraphNode_E_Star_C _Q_O_QGraphNode_E_S_QGraphNode_E_Star_C_E_Opt
%type <p_DatasetClause> DatasetClause _O_QDefaultGraphClause_E_Or_QNamedGraphClause_E_C DefaultGraphClause NamedGraphClause
%type <p_POS> SourceSelector
%type <p_WhereClause> WhereClause
%type <p_SolutionModifier> SolutionModifier
%type <p_LimitOffsetPair> LimitOffsetClauses _QLimitOffsetClauses_E_Opt _QLimitClause_E_S_QOffsetClause_E_Opt_Or_QOffsetClause_E_S_QLimitClause_E_Opt LimitClause _QLimitClause_E_Opt OffsetClause _QOffsetClause_E_Opt
%type <p_OrderConditions> _QOrderClause_E_Opt OrderClause _QOrderCondition_E_Plus
%type <p_OrderConditionPair> OrderCondition _O_QIT_ASC_E_Or_QIT_DESC_E_S_QBrackettedExpression_E_C
%type <p_e_ASCorDESC> _O_QIT_ASC_E_Or_QIT_DESC_E_C
%type <p_BindingClause> BindingClause _QBindingClause_E_Opt
%type <p_Bindings> _QBinding_E_Star
%type <p_Binding> Binding
%type <p_POS> _O_QVarOrTerm_E_Or_QIT_NULL_E_C
%type <p_POSs> _Q_O_QVarOrTerm_E_Or_QIT_NULL_E_C_E_Plus

%type <p_TableOperation> GroupGraphPattern _O_QIT_UNION_E_S_QGroupGraphPattern_E_C _O_QGraphPatternNotTriples_E_Or_QFilter_E_S_QGT_DOT_E_Opt_S_QTriplesBlock_E_Opt_C _O_QGraphPatternNotTriples_E_Or_QFilter_E_C GraphPatternNotTriples GroupOrUnionGraphPattern OptionalGraphPattern GraphGraphPattern _QTriplesBlock_E_Opt TriplesBlock _O_QGT_DOT_E_S_QTriplesBlock_E_Opt_C _Q_O_QGT_DOT_E_S_QTriplesBlock_E_Opt_C_E_Opt

%type <p_BasicGraphPattern> ConstructTriples _Q_O_QGT_DOT_E_S_QConstructTriples_E_Opt_C_E_Opt _O_QGT_DOT_E_S_QConstructTriples_E_Opt_C _QConstructTriples_E_Opt ConstructTemplate

%type <p_TableOperations> _Q_O_QGraphPatternNotTriples_E_Or_QFilter_E_S_QGT_DOT_E_Opt_S_QTriplesBlock_E_Opt_C_E_Star _Q_O_QIT_UNION_E_S_QGroupGraphPattern_E_C_E_Star

%type <p_Filter> Filter
%type <p_ArgList> ArgList _QArgList_E_Opt
%type <p_Expressions> _O_QNIL_E_Or_QGT_LPAREN_E_S_QExpression_E_S_QGT_COMMA_E_S_QExpression_E_Star_S_QGT_RPAREN_E_C _Q_O_QGT_OR_E_S_QConditionalAndExpression_E_C_E_Star _Q_O_QGT_AND_E_S_QValueLogical_E_C_E_Star _Q_O_QGT_PLUS_E_S_QMultiplicativeExpression_E_Or_QGT_MINUS_E_S_QMultiplicativeExpression_E_Or_QNumericLiteralPositive_E_Or_QNumericLiteralNegative_E_C_E_Star _Q_O_QGT_TIMES_E_S_QUnaryExpression_E_Or_QGT_DIVIDE_E_S_QUnaryExpression_E_C_E_Star
%type <p_POS> Verb VarOrIRIref VarOrTerm GraphNode Object GraphTerm BlankNode TriplesNode Generator
%type <p_RDFLiteral> RDFLiteral _QLabel_E_Opt
%type <p_NumericRDFLiteral> NumericLiteralUnsigned NumericLiteralPositive NumericLiteralNegative NumericLiteral
%type <p_BooleanRDFLiteral> BooleanLiteral
%type <p_string> String
%type <p_BNode> BlankNodePropertyList
%type <p_Variable> Var

/* Expressions */
%type <p_Expression> Expression Constraint _O_QConstraint_E_Or_QVar_E_C BrackettedExpression BuiltInCall FunctionCall ConditionalOrExpression _O_QGT_OR_E_S_QConditionalAndExpression_E_C ConditionalAndExpression _O_QGT_AND_E_S_QValueLogical_E_C ValueLogical RelationalExpression NumericExpression AdditiveExpression _O_QGT_PLUS_E_S_QMultiplicativeExpression_E_Or_QGT_MINUS_E_S_QMultiplicativeExpression_E_Or_QNumericLiteralPositive_E_Or_QNumericLiteralNegative_E_C MultiplicativeExpression _O_QGT_TIMES_E_S_QUnaryExpression_E_Or_QGT_DIVIDE_E_S_QUnaryExpression_E_C UnaryExpression PrimaryExpression RegexExpression _O_QGT_COMMA_E_S_QExpression_E_C _Q_O_QGT_COMMA_E_S_QExpression_E_C_E_Opt IRIrefOrFunction
%type <p_BooleanComparator> _O_QGT_EQUAL_E_S_QNumericExpression_E_Or_QGT_NEQUAL_E_S_QNumericExpression_E_Or_QGT_LT_E_S_QNumericExpression_E_Or_QGT_GT_E_S_QNumericExpression_E_Or_QGT_LE_E_S_QNumericExpression_E_Or_QGT_GE_E_S_QNumericExpression_E_C _Q_O_QGT_EQUAL_E_S_QNumericExpression_E_Or_QGT_NEQUAL_E_S_QNumericExpression_E_Or_QGT_LT_E_S_QNumericExpression_E_Or_QGT_GT_E_S_QNumericExpression_E_Or_QGT_LE_E_S_QNumericExpression_E_Or_QGT_GE_E_S_QNumericExpression_E_C_E_Opt

%type <p_URI> _O_QGT_DTYPE_E_S_QIRIref_E_C IRIref PrefixedName
%type <p_uri_or_langtag> _O_QLANGTAG_E_Or_QGT_DTYPE_E_S_QIRIref_E_C _Q_O_QLANGTAG_E_Or_QGT_DTYPE_E_S_QIRIref_E_C_E_Opt

/*
%type <p_void> _QTriplesBlock_E_Opt
%type <p_void> _QGT_DOT_E_Opt
%type <p_void> _Q_O_QGT_COMMA_E_S_QExpression_E_C_E_Star
%type <p_void> ConstructTriples _QConstructTriples_E_Opt
%type <p_void> _O_QGT_DOT_E_S_QConstructTriples_E_Opt_C
%type <p_void> _Q_O_QGT_DOT_E_S_QConstructTriples_E_Opt_C_E_Opt
%type <p_void> TriplesSameSubject
%type <p_void> PropertyListNotEmpty
%type <p_void> _O_QVerb_E_S_QObjectList_E_C
%type <p_void> _Q_O_QVerb_E_S_QObjectList_E_C_E_Opt
%type <p_void> _O_QGT_SEMI_E_S_QVerb_E_S_QObjectList_E_Opt_C
%type <p_void> _Q_O_QGT_SEMI_E_S_QVerb_E_S_QObjectList_E_Opt_C_E_Star
%type <p_void> PropertyList
%type <p_void> _QPropertyListNotEmpty_E_Opt
%type <p_void> ObjectList
%type <p_void> _O_QGT_COMMA_E_S_QObject_E_C
%type <p_void> _Q_O_QGT_COMMA_E_S_QObject_E_C_E_Star
*/
/* END TokenBlock */

//%destructor { delete $$; } BlankNode

 /*** END MapSet - Change the grammar's tokens above ***/

%{
#include "../MapSetScanner.hpp"

/* this "connects" the bison parser in the driver to the flex scanner class
 * object. it defines the yylex() function call to pull the next token from the
 * current lexer object of the driver context. */
#undef yylex
#define yylex driver.lexer->lex
%}

%% /*** Grammar Rules ***/

 /*** BEGIN MapSet - Change the grammar rules below ***/
MapSet:
    // Prologue Construct*
    {
	driver.root = new MapSet();
      }	Prologue AccessParms_Star Map_Star	{
	  $$ = driver.root;
      }
;

// Select | Construct | Describe | Ask
AccessParms_Star:
    
  | AccessParms_Star IT_REWRITEVAR Var RDFLiteral RDFLiteral	{
#if REGEX_LIB == SWOb_DISABLED
      throw std::string("not compiled with REGEX_LIB: can't map ") + $3->toString() + " from " + $4->toString() + " to " + $5->toString() + ".";
#else /* ! REGEX_LIB == SWOb_DISABLED */
#if NotYet
      driver.root->rewriteVars.push_back(POSmap($3, $4->getLexicalValue(), $5->getLexicalValue()));
#endif /* NotYet */
#endif /* ! REGEX_LIB == SWOb_DISABLED */
    }
  | AccessParms_Star IT_SERVER RDFLiteral	{
	static_cast<MapSet*>(driver.root)->server = $3;
    }
  | AccessParms_Star IT_USER RDFLiteral	{
	static_cast<MapSet*>(driver.root)->user = $3;
    }
  | AccessParms_Star IT_PASSWORD RDFLiteral	{
	static_cast<MapSet*>(driver.root)->password = $3;
    }
  | AccessParms_Star IT_DATABASE RDFLiteral	{
	static_cast<MapSet*>(driver.root)->database = $3;
    }
  | AccessParms_Star IT_STEMURI IRIref	{
	static_cast<MapSet*>(driver.root)->stemURI = $3;
    }
  | AccessParms_Star IT_PRIMARYKEY RDFLiteral	{
	static_cast<MapSet*>(driver.root)->primaryKey = $3;
    }
;

// Construct*
Map_Star:
    
  | Map_Star Construct	
;

// Label?
_QLabel_E_Opt:
    {
	$$ = NULL;
    }
  | IT_LABEL RDFLiteral	{
	$$ = $2;
    }
;

Prologue:
    // BaseDecl? PrefixDecl*
    _QBaseDecl_E_Opt _QPrefixDecl_E_Star
;

// BaseDecl?
_QBaseDecl_E_Opt:

    | BaseDecl
;

// PrefixDecl*
_QPrefixDecl_E_Star:

    | _QPrefixDecl_E_Star PrefixDecl
;

BaseDecl:
    IT_BASE IRI_REF	{
	driver.setBase($2);
    }
;

PrefixDecl:
    IT_PREFIX {
	driver.ignorePrefix(true);
      } PNAME_NS {
	  driver.ignorePrefix(false);
      } IRI_REF	{
	  std::string prefix($3->getLexicalValue());
	  driver.addPrefix(prefix.substr(0, prefix.length()-1), $5);
      }
;

// Var+
_QVar_E_Plus:
    Var	{
	$$ = new POSList;
	$$->push_back($1);
    }
  | _QVar_E_Plus Var	{
	$1->push_back($2);
	$$ = $1;
    }
;

// DatasetClause*
_QDatasetClause_E_Star:
    {
	$$ = new ProductionVector<const DatasetClause*>();
    }
  | _QDatasetClause_E_Star DatasetClause	{
	$1->push_back($2);
	$$ = $1;
    }
;

Construct:
    // 'CONSTRUCT' ConstructTemplate DatasetClause* WhereClause SolutionModifier
    _QLabel_E_Opt IT_CONSTRUCT ConstructTemplate _QDatasetClause_E_Star WhereClause SolutionModifier	{
	/* $2 is known to be a DefaultGraphPattern because of grammar restrictions. */
	Construct* constr = new Construct((DefaultGraphPattern*)$3, $4, $5, $6);
	static_cast<MapSet*>(driver.root)->maps.push_back(LabeledConstruct($1, constr));
    }
;

DatasetClause:
    // 'FROM' ( DefaultGraphClause | NamedGraphClause )
    IT_FROM _O_QDefaultGraphClause_E_Or_QNamedGraphClause_E_C	{
	$$ = $2;
    }
;

// DefaultGraphClause | NamedGraphClause
_O_QDefaultGraphClause_E_Or_QNamedGraphClause_E_C:
    DefaultGraphClause	{
	$$ = $1;
    }
  | NamedGraphClause	{
	$$ = $1;
    }
;

DefaultGraphClause:
    SourceSelector	{
	$$ = new DefaultGraphClause($1, driver.posFactory);
    }
;

NamedGraphClause:
    IT_NAMED SourceSelector	{
	$$ = new NamedGraphClause($2, driver.posFactory);
    }
;

SourceSelector:
    IRIref	{
	$$ = $1;
    }
;

WhereClause:
    // 'WHERE'? GroupGraphPattern BindingClause?
    _QIT_WHERE_E_Opt GroupGraphPattern _QBindingClause_E_Opt	{
	$$ = new WhereClause($2, $3);
    }
;

_QIT_WHERE_E_Opt:

    | IT_WHERE	;

// BindingClause?
_QBindingClause_E_Opt:
    {
	$$ = NULL;
    }
  | BindingClause	{
	$$ = $1;
    }
;

SolutionModifier:
    // OrderClause? LimitOffsetClauses?
    _QOrderClause_E_Opt _QLimitOffsetClauses_E_Opt	{
	$$ = new SolutionModifier($1, $2.limit, $2.offset);
    }
;

// OrderClause?
_QOrderClause_E_Opt:
    {
	$$ = NULL;
    }
  | OrderClause	{
	$$ = $1;
    }
;

// LimitOffsetClauses?
_QLimitOffsetClauses_E_Opt:
    {
	$$.limit = LIMIT_None;
	$$.offset = OFFSET_None;
    }
  | LimitOffsetClauses
;

LimitOffsetClauses:
    // LimitClause OffsetClause? | OffsetClause LimitClause?
    _QLimitClause_E_S_QOffsetClause_E_Opt_Or_QOffsetClause_E_S_QLimitClause_E_Opt
;

// OffsetClause?
_QOffsetClause_E_Opt:
    {
	$$.offset = OFFSET_None;
    }
  | OffsetClause	{
	$$ = $1;
    }
;

// LimitClause?
_QLimitClause_E_Opt:
    {
	$$.limit = LIMIT_None;
    }
  | LimitClause	{
	$$ = $1;
    }
;

// LimitClause OffsetClause? | OffsetClause LimitClause?
_QLimitClause_E_S_QOffsetClause_E_Opt_Or_QOffsetClause_E_S_QLimitClause_E_Opt:
    LimitClause _QOffsetClause_E_Opt	{
	$$.limit = $1.limit;
	$$.offset = $2.offset;
    }
  | OffsetClause _QLimitClause_E_Opt	{
	$$.limit = $2.limit;
	$$.offset = $1.offset;
    }
;

OrderClause:
    // 'ORDER' 'BY' OrderCondition+
    IT_ORDER IT_BY _QOrderCondition_E_Plus	{
	$$ = $3;
    }
;

// OrderCondition+
_QOrderCondition_E_Plus:
    OrderCondition	{
	$$ = new std::vector<s_OrderConditionPair>();
	$$->push_back($1);
    }
  | _QOrderCondition_E_Plus OrderCondition	{
	$1->push_back($2);
	$$ = $1;
    }
;

OrderCondition:
    // ( 'ASC' | 'DESC' ) BrackettedExpression
    _O_QIT_ASC_E_Or_QIT_DESC_E_S_QBrackettedExpression_E_C
  | // Constraint | Var
    _O_QConstraint_E_Or_QVar_E_C	{
	$$.ascOrDesc = ORDER_Asc;
	$$.expression = $1;
    }
;

// 'ASC' | 'DESC'
_O_QIT_ASC_E_Or_QIT_DESC_E_C:
    IT_ASC	{
	$$ = ORDER_Asc;
    }
  | IT_DESC	{
	$$ = ORDER_Desc;
    }
;

// ( 'ASC' | 'DESC' ) BrackettedExpression
_O_QIT_ASC_E_Or_QIT_DESC_E_S_QBrackettedExpression_E_C:
    // 'ASC' | 'DESC'
    _O_QIT_ASC_E_Or_QIT_DESC_E_C BrackettedExpression	{
	$$.ascOrDesc = $1;
	$$.expression = $2;
    }
;

// Constraint | Var
_O_QConstraint_E_Or_QVar_E_C:
    Constraint	{
	$$ = $1;
    }
  | Var	{
	$$ = new VarExpression($1);
    }
;

LimitClause:
    IT_LIMIT INTEGER	{
	$$.limit = ((IntegerRDFLiteral*)$2)->getValue();
    }
;

OffsetClause:
    IT_OFFSET INTEGER	{
	$$.offset = ((IntegerRDFLiteral*)$2)->getValue();
    }
;

BindingClause:
    // 'BINDINGS' Var+ '{' Binding* '}'
    IT_BINDINGS _QVar_E_Plus GT_LCURLEY {
	driver.curBindingClause = new BindingClause($2);
      } _QBinding_E_Star GT_RCURLEY	{
	  $$ = driver.curBindingClause;
	  driver.curBindingClause = NULL;
      }
;

// Binding*
_QBinding_E_Star:
    {
	$$ = NULL;
    }
  | _QBinding_E_Star Binding	{
	driver.curBindingClause->push_back($2);
	$$ = NULL;
    }
;

Binding:
    // '(' ( VarOrTerm | 'NULL' )+ ')"/
    GT_LPAREN {
	driver.curBinding = new Binding();
      } _Q_O_QVarOrTerm_E_Or_QIT_NULL_E_C_E_Plus GT_RPAREN	{
	  $$ = driver.curBinding;
	  driver.curBinding = NULL;
      }
;

// VarOrTerm | 'NULL'
_O_QVarOrTerm_E_Or_QIT_NULL_E_C:
    VarOrTerm	{
	$$ = $1;
    }
  | IT_NULL	{
	$$ = driver.getNULL();
    }
;

// ( VarOrTerm | 'NULL' )+
_Q_O_QVarOrTerm_E_Or_QIT_NULL_E_C_E_Plus:
    _O_QVarOrTerm_E_Or_QIT_NULL_E_C	{
	driver.curBinding->push_back($1);
	$$ = NULL;
    }
  | _Q_O_QVarOrTerm_E_Or_QIT_NULL_E_C_E_Plus _O_QVarOrTerm_E_Or_QIT_NULL_E_C	{
	driver.curBinding->push_back($2);
	$$ = NULL;
    }
;

GroupGraphPattern:
    // '{' TriplesBlock? ( ( GraphPatternNotTriples | Filter ) '.'? TriplesBlock? )* '}'
    GT_LCURLEY {
	driver.neededBGP = NULL;
	driver.bgpStack.push_back(NULL);
      } _QTriplesBlock_E_Opt _Q_O_QGraphPatternNotTriples_E_Or_QFilter_E_S_QGT_DOT_E_Opt_S_QTriplesBlock_E_Opt_C_E_Star GT_RCURLEY	{
	  if (($3 != NULL && $4->size() > 0) ||
	      ($3 == NULL && $4->size() > 1)) {
	      TableConjunction* ret = new TableConjunction();
	      $$ = ret;
	      if ($3 != NULL) ret->addTableOperation($3, true);
	      for (std::vector<const TableOperation*>::iterator it = $4->begin();
		   it != $4->end(); ++it)
		  ret->addTableOperation(*it, true);
	  } else if ($3 != NULL)
	      $$ = $3;
	  else if ($4->size() > 0) // sole item in ProductionVector
	      $$ = (TableOperation*)$4->at(0);
	  else
	      $$ = driver.makeBasicGraphPattern(); // or NULL -- are those simplifications OK?
	  $4->clear();
	  delete $4;

	  driver.neededBGP = NULL;
	  driver.bgpStack.pop_back();
	  /* Prevents optimization in e.g. <data-r2/algebra/join-combo-1.rq>
	   *  of ?a :p ?c . OPTIONAL { ?a :r ?d } ?a ?p 1 .
	   *  to { ?a :p ?c . ?a ?p 1 . } OPTIONAL { ?a :r ?d }
	   * now { ?a :p ?c . } OPTIONAL { ?a :r ?d } { ?a ?p 1 . }
	   * @@@ should it be the former? if so, remove or put a switch on this.
	   */
	  driver.bgpStack.back() = NULL;
      }
;

// TriplesBlock?
_QTriplesBlock_E_Opt:
    { $$ = NULL; }
  | TriplesBlock	{
	$$ = $1;
    }
;

// GraphPatternNotTriples | Filter
_O_QGraphPatternNotTriples_E_Or_QFilter_E_C:
    GraphPatternNotTriples
  | Filter	{
	$$ = driver.neededBGP;
	driver.neededBGP = NULL;
    }
;

// '.'?
_QGT_DOT_E_Opt:

    | GT_DOT
;

// ( GraphPatternNotTriples | Filter ) '.'? TriplesBlock?
_O_QGraphPatternNotTriples_E_Or_QFilter_E_S_QGT_DOT_E_Opt_S_QTriplesBlock_E_Opt_C:
    _O_QGraphPatternNotTriples_E_Or_QFilter_E_C _QGT_DOT_E_Opt _QTriplesBlock_E_Opt	{
	if ($1 && $3) { // ??? && $3 != $1
	    TableConjunction* ret = new TableConjunction();
	    $$ = ret;
	    ret->addTableOperation($1, true);
	    ret->addTableOperation($3, true);
	} else if ($1) {
	    $$ = $1;
	} else {
	    $$ = $3;
	}
    }
;

// ( ( GraphPatternNotTriples | Filter ) '.'? TriplesBlock? )*
_Q_O_QGraphPatternNotTriples_E_Or_QFilter_E_S_QGT_DOT_E_Opt_S_QTriplesBlock_E_Opt_C_E_Star:
    {
	$$ = new ProductionVector<const TableOperation*>();
    }
  | // ( GraphPatternNotTriples | Filter ) '.'? TriplesBlock?
    _Q_O_QGraphPatternNotTriples_E_Or_QFilter_E_S_QGT_DOT_E_Opt_S_QTriplesBlock_E_Opt_C_E_Star _O_QGraphPatternNotTriples_E_Or_QFilter_E_S_QGT_DOT_E_Opt_S_QTriplesBlock_E_Opt_C	{
	if ($2)
	    $1->push_back($2);
	$$ = $1;
    }
;

TriplesBlock:
    // TriplesSameSubject ( '.' TriplesBlock? )?
    TriplesSameSubject _Q_O_QGT_DOT_E_S_QTriplesBlock_E_Opt_C_E_Opt	{
	$$ = driver.neededBGP ? driver.neededBGP : $2;
	driver.neededBGP = NULL;
    }
;

// '.' TriplesBlock?
_O_QGT_DOT_E_S_QTriplesBlock_E_Opt_C:
    GT_DOT _QTriplesBlock_E_Opt	{
	$$ = $2;
    }
;

// ( '.' TriplesBlock? )?
_Q_O_QGT_DOT_E_S_QTriplesBlock_E_Opt_C_E_Opt:
    { $$ = NULL; }
  | // '.' TriplesBlock?
    _O_QGT_DOT_E_S_QTriplesBlock_E_Opt_C
;

GraphPatternNotTriples:
    OptionalGraphPattern
    | GroupOrUnionGraphPattern
    | GraphGraphPattern
;

OptionalGraphPattern:
    IT_OPTIONAL	{
	$<p_FilterHolder>$ = new FilterHolder();
	driver.bgpStack.push_back($<p_FilterHolder>$);
      } GroupGraphPattern	{
	  $$ = new OptionalGraphPattern($3);
	  $<p_FilterHolder>2->copyFiltersTo($$);
	  delete $<p_FilterHolder>2;
	  driver.bgpStack.pop_back();
	  driver.neededBGP = NULL;
	  driver.bgpStack.back() = NULL;
      }
;

GraphGraphPattern:
    IT_GRAPH VarOrIRIref {
	driver.curGraphNameStack.push($2);
      } GroupGraphPattern	{
	  $$ = new GraphGraphPattern($2, $4);
	  driver.curGraphNameStack.pop();
	  driver.neededBGP = NULL;
	  driver.bgpStack.back() = NULL;
	}
;

GroupOrUnionGraphPattern:
    // GroupGraphPattern ( 'UNION' GroupGraphPattern )*
    GroupGraphPattern _Q_O_QIT_UNION_E_S_QGroupGraphPattern_E_C_E_Star	{
	if ($2->size() > 0) {
	    TableDisjunction* ret= new TableDisjunction();
	    $$ = ret;
	    ret->addTableOperation($1, true);
	    for (std::vector<const TableOperation*>::iterator it = $2->begin();
		 it != $2->end(); ++it)
		ret->addTableOperation(*it, true);
	} else
	    $$ = $1;
	$2->clear();
	delete $2;
    }
;

// 'UNION' GroupGraphPattern
_O_QIT_UNION_E_S_QGroupGraphPattern_E_C:
    IT_UNION GroupGraphPattern	{
	$$ = $2;
    }
;

// ( 'UNION' GroupGraphPattern )*
_Q_O_QIT_UNION_E_S_QGroupGraphPattern_E_C_E_Star:
    {
	$$ = new ProductionVector<const TableOperation*>();
    }
  | _Q_O_QIT_UNION_E_S_QGroupGraphPattern_E_C_E_Star _O_QIT_UNION_E_S_QGroupGraphPattern_E_C	{
	$1->push_back($2);
	$$ = $1;
    }
;

Filter:
    IT_FILTER Constraint	{
	$$ = new Filter($2);
	size_t bgps = driver.bgpStack.size();
	FilterHolder* h = bgps <= 1 ? NULL : 
	    dynamic_cast<FilterHolder*>(driver.bgpStack.at(bgps - 2));
#if 0
	if (h == NULL) {
	    driver.makeBasicGraphPattern();
	    driver.bgpStack.back()->addFilter($$);
	} else {
	    h->addFilter($$);
	}
#endif
    }
;

Constraint:
    BrackettedExpression	{
	$$ = $1;
    }
  | BuiltInCall	{
	$$ = $1;
    }
  | FunctionCall	{
	$$ = $1;
    }
;

FunctionCall:
    IRIref ArgList	{
	$$ = new FunctionCallExpression(new FunctionCall($1, $2));
    }
;

ArgList:
    // ( NIL | '(' Expression ( ',' Expression )* ')' )
    _O_QNIL_E_Or_QGT_LPAREN_E_S_QExpression_E_S_QGT_COMMA_E_S_QExpression_E_Star_S_QGT_RPAREN_E_C	{
	$$ = new ArgList($1);
    }
;

// ',' Expression
_O_QGT_COMMA_E_S_QExpression_E_C:
    GT_COMMA Expression	{
	$$ = $2;
    }
;

// ( ',' Expression )*
_Q_O_QGT_COMMA_E_S_QExpression_E_C_E_Star:

  | _Q_O_QGT_COMMA_E_S_QExpression_E_C_E_Star _O_QGT_COMMA_E_S_QExpression_E_C	{
	driver.curExprList->push_back($2);
    }
;

// ( NIL | '(' Expression ( ',' Expression )* ')' )
_O_QNIL_E_Or_QGT_LPAREN_E_S_QExpression_E_S_QGT_COMMA_E_S_QExpression_E_Star_S_QGT_RPAREN_E_C:
    NIL	{
	$$ = NULL;
    }
  | // '(' Expression ( ',' Expression )* ')'
    GT_LPAREN Expression {
	driver.curExprList = new ProductionVector<const Expression*>($2);
      } _Q_O_QGT_COMMA_E_S_QExpression_E_C_E_Star GT_RPAREN	{
	  $$ = driver.curExprList;
	  driver.curExprList = NULL;
      }
;

ConstructTemplate:
    // '{' ConstructTriples? '}'
    GT_LCURLEY {
	driver.neededBGP = NULL;
	driver.bgpStack.push_back(NULL);
      } _QConstructTriples_E_Opt GT_RCURLEY	{
	  $$ = $3;
	  driver.neededBGP = NULL;
	  driver.bgpStack.pop_back();
      }
;

// ConstructTriples?
_QConstructTriples_E_Opt:
    { $$ = NULL; }
  | ConstructTriples	{
	$$ = $1;
    }
;

ConstructTriples:
    // TriplesSameSubject ( '.' ConstructTriples? )?
    TriplesSameSubject _Q_O_QGT_DOT_E_S_QConstructTriples_E_Opt_C_E_Opt	{
	$$ = driver.neededBGP ? driver.neededBGP : $2;
	driver.neededBGP = NULL;
    }
;

// '.' ConstructTriples?
_O_QGT_DOT_E_S_QConstructTriples_E_Opt_C:
    GT_DOT _QConstructTriples_E_Opt	{
	$$ = $2;
    }
;

// ( '.' ConstructTriples? )?
_Q_O_QGT_DOT_E_S_QConstructTriples_E_Opt_C_E_Opt:
    { $$ = NULL; }
  | _O_QGT_DOT_E_S_QConstructTriples_E_Opt_C
;

TriplesSameSubject:
    VarOrTerm {
	driver.curSubject = $1;
    } PropertyListNotEmpty
  | TriplesNode {
	driver.curSubject = $1;
    } PropertyList
;

PropertyListNotEmpty:
    // Verb ObjectList ( ';' ( Verb ObjectList )? )*
    Verb ObjectList _Q_O_QGT_SEMI_E_S_QVerb_E_S_QObjectList_E_Opt_C_E_Star
;

// Verb ObjectList
_O_QVerb_E_S_QObjectList_E_C:
    Verb ObjectList
;

// ( Verb ObjectList )?
_Q_O_QVerb_E_S_QObjectList_E_C_E_Opt:

    | _O_QVerb_E_S_QObjectList_E_C
;

// ';' ( Verb ObjectList )?
_O_QGT_SEMI_E_S_QVerb_E_S_QObjectList_E_Opt_C:
    GT_SEMI _Q_O_QVerb_E_S_QObjectList_E_C_E_Opt
;

// ( ';' ( Verb ObjectList )? )*
_Q_O_QGT_SEMI_E_S_QVerb_E_S_QObjectList_E_Opt_C_E_Star:

    | _Q_O_QGT_SEMI_E_S_QVerb_E_S_QObjectList_E_Opt_C_E_Star _O_QGT_SEMI_E_S_QVerb_E_S_QObjectList_E_Opt_C
;

PropertyList:
    // PropertyListNotEmpty?
    _QPropertyListNotEmpty_E_Opt
;

// PropertyListNotEmpty?
_QPropertyListNotEmpty_E_Opt:

    | PropertyListNotEmpty
;

ObjectList:
    // Object ( ',' Object )*
    Object _Q_O_QGT_COMMA_E_S_QObject_E_C_E_Star
;

// ',' Object
_O_QGT_COMMA_E_S_QObject_E_C:
    GT_COMMA Object
;

// ( ',' Object )*
_Q_O_QGT_COMMA_E_S_QObject_E_C_E_Star:

    | _Q_O_QGT_COMMA_E_S_QObject_E_C_E_Star _O_QGT_COMMA_E_S_QObject_E_C
;

Object:
    GraphNode	{
	driver.makeBasicGraphPattern();
	driver.bgpStack.back()->addTriplePattern(driver.posFactory->getTriple(driver.curSubject, driver.curPredicate, $1));
	$$ = $1;
    }
;

Verb:
    VarOrIRIref	{
	$$ = $1;
	driver.curPredicate = $$;
    }
  | IT_a	{
	$$ = driver.getURI("http://www.w3.org/1999/02/22-rdf-syntax-ns#type");
	driver.curPredicate = $$;
    }
;

TriplesNode:
    Generator	{
	$$ = $1;
    }
  | BlankNodePropertyList	{
	$$ = $1;
    }
;

BlankNodePropertyList:
    GT_LBRACKET {
	$<p_SubjectPredicatePair>$.subject = driver.curSubject;
	$<p_SubjectPredicatePair>$.predicate = driver.curPredicate;
	driver.curSubject = driver.createBNode();
      } PropertyListNotEmpty GT_RBRACKET	{
	  $$ = (BNode*)driver.curSubject; // could store w/ type in ctx..
	  driver.curSubject = $<p_SubjectPredicatePair>2.subject;
	  driver.curPredicate = $<p_SubjectPredicatePair>2.predicate;
      }
;

Generator:
    // ('members' | 'starts' | 'ends' | 'any' | 'unordered')? '(' ( GraphNode GraphNode* )? ')' ;
    _Q_O_QIT_MEMBERS_E_Or_QIT_STARTS_E_Or_QIT_ENDS_E_Or_QIT_ANY_E_Or_QIT_UNORDERED_E_C_E_Opt GT_LPAREN _Q_O_QGraphNode_E_S_QGraphNode_E_Star_C_E_Opt GT_RPAREN	{
	if ($1 == LIST_exact) {
	    $$ = driver.createBNode();
	    const POS* tail = $$;
	    ProductionVector<const POS*>* members = $3;
	    const URI* first = driver.getURI("http://www.w3.org/1999/02/22-rdf-syntax-ns#first");
	    const URI* rest = driver.getURI("http://www.w3.org/1999/02/22-rdf-syntax-ns#rest");
	    const POS* nil = driver.getURI("http://www.w3.org/1999/02/22-rdf-syntax-ns#nil");
	    driver.makeBasicGraphPattern();
	    for (unsigned i = 0; i < members->size(); i++) {
		driver.bgpStack.back()->addTriplePattern(driver.posFactory->getTriple(tail, first, members->at(i)));
		const POS* nextTail = i == members->size()-1 ? nil : driver.createBNode();
		driver.bgpStack.back()->addTriplePattern(driver.posFactory->getTriple(tail, rest, nextTail));
		tail = nextTail;
	    }
	    members->clear();
	    delete members;
	} else {
	    error(*(yylocation_stack_.end()), "unsupported function");
	}
    }
;

_O_QIT_MEMBERS_E_Or_QIT_STARTS_E_Or_QIT_ENDS_E_Or_QIT_ANY_E_Or_QIT_UNORDERED_E_C:
    // 'members' | 'starts' | 'ends' | 'any' | 'unordered'
    IT_MEMBERS	{
	$$ = LIST_members;
    }
  | IT_STARTS	{
	$$ = LIST_starts;
    }
  | IT_ENDS	{
	$$ = LIST_ends;
    }
  | IT_ANY	{
	$$ = LIST_any;
    }
  | IT_UNORDERED	{
	$$ = LIST_unordered;
    }
;

_Q_O_QIT_MEMBERS_E_Or_QIT_STARTS_E_Or_QIT_ENDS_E_Or_QIT_ANY_E_Or_QIT_UNORDERED_E_C_E_Opt:
    // ('members' | 'starts' | 'ends' | 'any' | 'unordered')?
    {
	$$ = LIST_exact;
    }
  | _O_QIT_MEMBERS_E_Or_QIT_STARTS_E_Or_QIT_ENDS_E_Or_QIT_ANY_E_Or_QIT_UNORDERED_E_C	
;

// GraphNode*
_QGraphNode_E_Star:
    {
	$$ = new ProductionVector<const POS*>();
    }
  | _QGraphNode_E_Star GraphNode	{
	$1->push_back($2);
	$$ = $1;
    }
;

// GraphNode GraphNode*
_O_QGraphNode_E_S_QGraphNode_E_Star_C:
    GraphNode _QGraphNode_E_Star	{
	/* no push_front
	   $2->push_front($1);
	   $$ = $2;
	   so copy the vector. */
	$$ = new ProductionVector<const POS*>();
	$$->push_back($1);
	for (std::vector<const POS*>::iterator it = $2->begin();
	     it != $2->end(); ++it)
	    $$->push_back(*it);
	$2->clear();
	delete $2;
    }
;

// ( GraphNode GraphNode* )?
_Q_O_QGraphNode_E_S_QGraphNode_E_Star_C_E_Opt:
    {
	$$ = new ProductionVector<const POS*>();
    }
    | _O_QGraphNode_E_S_QGraphNode_E_Star_C	
;

GraphNode:
    VarOrTerm	{
	$$ = $1;
    }
  | TriplesNode	{
	$$ = $1;
    }
;

VarOrTerm:
    Var	{
	$$ = $1;
    }
  | GraphTerm	{
	$$ = $1;
    }
;

VarOrIRIref:
    Var	{
	$$ = $1;
    }
  | IRIref	{
	$$ = $1;
    }
;

Var:
    VAR1	{
	$$ = $1;
    }
  | VAR2	{
	$$ = $1;
    }
;

GraphTerm:
    IRIref	{
	$$ = $1;
    }
  | RDFLiteral	{
	$$ = $1;
    }
  | NumericLiteral	{
	$$ = $1;
    }
  | BooleanLiteral	{
	$$ = $1;
    }
  | BlankNode	{
	$$ = $1;
    }
  | NIL	{
	$$ = driver.getURI("http://www.w3.org/1999/02/22-rdf-syntax-ns#nil"); // !!! new GraphTerm_rule5($1);
    }
;

Expression:
    ConditionalOrExpression	{
	$$ = $1;
    }
;

ConditionalOrExpression:
    // ConditionalAndExpression ( '||' ConditionalAndExpression )*
    ConditionalAndExpression _Q_O_QGT_OR_E_S_QConditionalAndExpression_E_C_E_Star	{
	$$ = $2->size() > 0 ? new BooleanDisjunction($1, $2) : $1;
	$2->clear();
	delete $2;
    }
;

// '||' ConditionalAndExpression
_O_QGT_OR_E_S_QConditionalAndExpression_E_C:
    GT_OR ConditionalAndExpression	{
	$$ = $2;
    }
;

// ( '||' ConditionalAndExpression )*
_Q_O_QGT_OR_E_S_QConditionalAndExpression_E_C_E_Star:
    {
	$$ = new ProductionVector<const Expression*>();
    }
  | _Q_O_QGT_OR_E_S_QConditionalAndExpression_E_C_E_Star _O_QGT_OR_E_S_QConditionalAndExpression_E_C	{
	$1->push_back($2);
	$$ = $1;
    }
;

ConditionalAndExpression:
    // ValueLogical ( '&&' ValueLogical )*
    ValueLogical _Q_O_QGT_AND_E_S_QValueLogical_E_C_E_Star	{
	$$ = $2->size() > 0 ? new BooleanConjunction($1, $2) : $1;
	$2->clear();
	delete $2;
    }
;

// '&&' ValueLogical
_O_QGT_AND_E_S_QValueLogical_E_C:
    GT_AND ValueLogical	{
	$$ = $2;
    }
;

// ( '&&' ValueLogical )*
_Q_O_QGT_AND_E_S_QValueLogical_E_C_E_Star:
    {
	$$ = new ProductionVector<const Expression*>();
    }
  | _Q_O_QGT_AND_E_S_QValueLogical_E_C_E_Star _O_QGT_AND_E_S_QValueLogical_E_C	{
	$1->push_back($2);
	$$ = $1;
    }
;

ValueLogical:
    RelationalExpression	{
	$$ = $1;
    }
;

RelationalExpression:
    // NumericExpression ( '=' NumericExpression | '!=' NumericExpression | '<' NumericExpression | '>' NumericExpression | '<=' NumericExpression | '>=' NumericExpression )?
    NumericExpression _Q_O_QGT_EQUAL_E_S_QNumericExpression_E_Or_QGT_NEQUAL_E_S_QNumericExpression_E_Or_QGT_LT_E_S_QNumericExpression_E_Or_QGT_GT_E_S_QNumericExpression_E_Or_QGT_LE_E_S_QNumericExpression_E_Or_QGT_GE_E_S_QNumericExpression_E_C_E_Opt	{
	if ($2) {
	    $2->setLeftParm($1);
	    $$ = new ComparatorExpression($2); // !!!
	} else
	    $$ = $1;
    }
;

// '=' NumericExpression | '!=' NumericExpression | '<' NumericExpression | '>' NumericExpression | '<=' NumericExpression | '>=' NumericExpression
_O_QGT_EQUAL_E_S_QNumericExpression_E_Or_QGT_NEQUAL_E_S_QNumericExpression_E_Or_QGT_LT_E_S_QNumericExpression_E_Or_QGT_GT_E_S_QNumericExpression_E_Or_QGT_LE_E_S_QNumericExpression_E_Or_QGT_GE_E_S_QNumericExpression_E_C:
    GT_EQUAL NumericExpression	{
	$$ = new BooleanEQ($2);
    }
  | GT_NEQUAL NumericExpression	{
	$$ = new BooleanNE($2);
    }
  | GT_LT NumericExpression	{
	$$ = new BooleanLT($2);
    }
  | GT_GT NumericExpression	{
	$$ = new BooleanGT($2);
    }
  | GT_LE NumericExpression	{
    $$ = new BooleanLE($2);
    }
  | GT_GE NumericExpression	{
	$$ = new BooleanGE($2);
    }
;

// ( '=' NumericExpression | '!=' NumericExpression | '<' NumericExpression | '>' NumericExpression | '<=' NumericExpression | '>=' NumericExpression )?
_Q_O_QGT_EQUAL_E_S_QNumericExpression_E_Or_QGT_NEQUAL_E_S_QNumericExpression_E_Or_QGT_LT_E_S_QNumericExpression_E_Or_QGT_GT_E_S_QNumericExpression_E_Or_QGT_LE_E_S_QNumericExpression_E_Or_QGT_GE_E_S_QNumericExpression_E_C_E_Opt:
    {
	$$ = NULL;
    }

  | _O_QGT_EQUAL_E_S_QNumericExpression_E_Or_QGT_NEQUAL_E_S_QNumericExpression_E_Or_QGT_LT_E_S_QNumericExpression_E_Or_QGT_GT_E_S_QNumericExpression_E_Or_QGT_LE_E_S_QNumericExpression_E_Or_QGT_GE_E_S_QNumericExpression_E_C	{
	$$ = $1;
    }
;

NumericExpression:
    AdditiveExpression	{
	$$ = $1;
    }
;

AdditiveExpression:
    // MultiplicativeExpression ( '+' MultiplicativeExpression | '-' MultiplicativeExpression | NumericLiteralPositive | NumericLiteralNegative )*
    MultiplicativeExpression _Q_O_QGT_PLUS_E_S_QMultiplicativeExpression_E_Or_QGT_MINUS_E_S_QMultiplicativeExpression_E_Or_QNumericLiteralPositive_E_Or_QNumericLiteralNegative_E_C_E_Star	{
	$$ = $2->size() > 0 ? new ArithmeticSum($1, $2) : $1;
	$2->clear();
	delete $2;
    }
;

// '+' MultiplicativeExpression | '-' MultiplicativeExpression | NumericLiteralPositive | NumericLiteralNegative
_O_QGT_PLUS_E_S_QMultiplicativeExpression_E_Or_QGT_MINUS_E_S_QMultiplicativeExpression_E_Or_QNumericLiteralPositive_E_Or_QNumericLiteralNegative_E_C:
    GT_PLUS MultiplicativeExpression	{
	$$ = $2;
    }
  | GT_MINUS MultiplicativeExpression	{
	$$ = new ArithmeticNegation($2);
    }
  | NumericLiteralPositive	{
	$$ = new NumberExpression($1);
    }
  | NumericLiteralNegative	{
	$$ = new NumberExpression($1);
    }
;

// ( '+' MultiplicativeExpression | '-' MultiplicativeExpression | NumericLiteralPositive | NumericLiteralNegative )*
_Q_O_QGT_PLUS_E_S_QMultiplicativeExpression_E_Or_QGT_MINUS_E_S_QMultiplicativeExpression_E_Or_QNumericLiteralPositive_E_Or_QNumericLiteralNegative_E_C_E_Star:
    {
	$$ = new ProductionVector<const Expression*>();
    }
  | _Q_O_QGT_PLUS_E_S_QMultiplicativeExpression_E_Or_QGT_MINUS_E_S_QMultiplicativeExpression_E_Or_QNumericLiteralPositive_E_Or_QNumericLiteralNegative_E_C_E_Star _O_QGT_PLUS_E_S_QMultiplicativeExpression_E_Or_QGT_MINUS_E_S_QMultiplicativeExpression_E_Or_QNumericLiteralPositive_E_Or_QNumericLiteralNegative_E_C	{
	$1->push_back($2);
	$$ = $1;
    }
;

MultiplicativeExpression:
    // UnaryExpression ( '*' UnaryExpression | '/' UnaryExpression )*
    UnaryExpression _Q_O_QGT_TIMES_E_S_QUnaryExpression_E_Or_QGT_DIVIDE_E_S_QUnaryExpression_E_C_E_Star	{
	$$ = $2->size() > 0 ? new ArithmeticProduct($1, $2) : $1;
	$2->clear();
	delete $2;
    }
;

// '*' UnaryExpression | '/' UnaryExpression
_O_QGT_TIMES_E_S_QUnaryExpression_E_Or_QGT_DIVIDE_E_S_QUnaryExpression_E_C:
    GT_TIMES UnaryExpression	{
	$$ = $2;
    }
  | GT_DIVIDE UnaryExpression	{
	$$ = new ArithmeticInverse($2);
    }
;

// ( '*' UnaryExpression | '/' UnaryExpression )*
_Q_O_QGT_TIMES_E_S_QUnaryExpression_E_Or_QGT_DIVIDE_E_S_QUnaryExpression_E_C_E_Star:
    {
	$$ = new ProductionVector<const Expression*>();
    }
  | _Q_O_QGT_TIMES_E_S_QUnaryExpression_E_Or_QGT_DIVIDE_E_S_QUnaryExpression_E_C_E_Star _O_QGT_TIMES_E_S_QUnaryExpression_E_Or_QGT_DIVIDE_E_S_QUnaryExpression_E_C	{
	$1->push_back($2);
	$$ = $1;
    }
;

UnaryExpression:
    GT_NOT PrimaryExpression	{
	$$ = new BooleanNegation($2);
    }
  | GT_PLUS PrimaryExpression	{
	$$ = $2;
    }
  | GT_MINUS PrimaryExpression	{
	$$ = new ArithmeticNegation($2);
    }
  | PrimaryExpression	{
	$$ = $1;
    }
;

PrimaryExpression:
    BrackettedExpression	{
	$$ = $1;
    }
  | BuiltInCall	{
	$$ = $1;
    }
  | IRIrefOrFunction	{
	$$ = $1;
    }
  | RDFLiteral	{
	$$ = new LiteralExpression($1);
    }
  | NumericLiteral	{
	$$ = new NumberExpression($1);
    }
  | BooleanLiteral	{
	$$ = new BooleanExpression($1);
    }
  | Var	{
	$$ = new VarExpression($1);
    }
;

BrackettedExpression:
    GT_LPAREN Expression GT_RPAREN	{
	$$ = $2;
    }
;

BuiltInCall:
    IT_STR GT_LPAREN Expression GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(driver.getURI("http://www.w3.org/TR/rdf-sparql-query/#func-str"), $3, NULL, NULL));
    }
  | IT_LANG GT_LPAREN Expression GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(driver.getURI("http://www.w3.org/TR/rdf-sparql-query/#func-lang"), $3, NULL, NULL));
    }
  | IT_LANGMATCHES GT_LPAREN Expression GT_COMMA Expression GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(driver.getURI("http://www.w3.org/TR/rdf-sparql-query/#func-langMatches"), $3, $5, NULL));
    }
  | IT_DATATYPE GT_LPAREN Expression GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(driver.getURI("http://www.w3.org/TR/rdf-sparql-query/#func-datatype"), $3, NULL, NULL));
    }
  | IT_BOUND GT_LPAREN Var GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(driver.getURI("http://www.w3.org/TR/rdf-sparql-query/#func-bound"), new VarExpression($3), NULL, NULL));
    }
  | IT_sameTerm GT_LPAREN Expression GT_COMMA Expression GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(driver.getURI("http://www.w3.org/TR/rdf-sparql-query/#func-sameTerm"), $3, $5, NULL));
    }
  | IT_isIRI GT_LPAREN Expression GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(driver.getURI("http://www.w3.org/TR/rdf-sparql-query/#func-isIRI"), $3, NULL, NULL));
    }
  | IT_isURI GT_LPAREN Expression GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(driver.getURI("http://www.w3.org/TR/rdf-sparql-query/#func-isIRI"), $3, NULL, NULL));
    }
  | IT_isBLANK GT_LPAREN Expression GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(driver.getURI("http://www.w3.org/TR/rdf-sparql-query/#func-isBlank"), $3, NULL, NULL));
    }
  | IT_isLITERAL GT_LPAREN Expression GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(driver.getURI("http://www.w3.org/TR/rdf-sparql-query/#func-isLiteral"), $3, NULL, NULL));
    }
  | RegexExpression	{
	$$ = $1;
    }
;

RegexExpression:
    // 'REGEX' '(' Expression ',' Expression ( ',' Expression )? ')'
    IT_REGEX GT_LPAREN Expression GT_COMMA Expression _Q_O_QGT_COMMA_E_S_QExpression_E_C_E_Opt GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(driver.getURI("http://www.w3.org/TR/rdf-sparql-query/#funcex-regex"), $3, $5, $6));
    }
;

// ( ',' Expression )?
_Q_O_QGT_COMMA_E_S_QExpression_E_C_E_Opt:
    {
	$$ = NULL;
    }
  | _O_QGT_COMMA_E_S_QExpression_E_C	{
	$$ = $1;
    }
;

IRIrefOrFunction:
    IRIref _QArgList_E_Opt	{
	if ($2)
	    $$ = new FunctionCallExpression(new FunctionCall($1, $2));
	else
	    $$ = new URIExpression($1);
    }
;

// IRIref ArgList?
_QArgList_E_Opt:
    {
	$$ = NULL;
    }
  | ArgList	{
	$$ = $1;
    }
;

RDFLiteral:
    // String ( LANGTAG | ( '^^' IRIref ) )?
    String _Q_O_QLANGTAG_E_Or_QGT_DTYPE_E_S_QIRIref_E_C_E_Opt	{
	$$ = driver.getRDFLiteral(*$1, $2.uri, $2.langtag);
	delete $1;
    }
;

// '^^' IRIref
_O_QGT_DTYPE_E_S_QIRIref_E_C:
    GT_DTYPE IRIref	{
	$$ = $2;
    }
;

// LANGTAG | ( '^^' IRIref )
_O_QLANGTAG_E_Or_QGT_DTYPE_E_S_QIRIref_E_C:
    LANGTAG	{
	$$.uri = NULL;
	$$.langtag = $1;
    }
  | _O_QGT_DTYPE_E_S_QIRIref_E_C	{
	$$.uri = $1;
	$$.langtag = NULL;
    }
;

// ( LANGTAG | ( '^^' IRIref ) )?
_Q_O_QLANGTAG_E_Or_QGT_DTYPE_E_S_QIRIref_E_C_E_Opt:
    {
	$$.uri = NULL;
	$$.langtag = NULL;
    }
  | _O_QLANGTAG_E_Or_QGT_DTYPE_E_S_QIRIref_E_C	{
	$$ = $1;
    }
;

NumericLiteral:
    NumericLiteralUnsigned	{
	$$ = $1;
    }
  | NumericLiteralPositive	{
	$$ = $1;
    }
  | NumericLiteralNegative	{
	$$ = $1;
    }
;

NumericLiteralUnsigned:
    INTEGER	{
	$$ = $1;
    }
  | DECIMAL	{
	$$ = $1;
    }
  | DOUBLE	{
	$$ = $1;
    }
;

NumericLiteralPositive:
    INTEGER_POSITIVE	{
	$$ = $1;
    }
  | DECIMAL_POSITIVE	{
	$$ = $1;
    }
  | DOUBLE_POSITIVE	{
	$$ = $1;
    }
;

NumericLiteralNegative:
    INTEGER_NEGATIVE	{
	$$ = $1;
    }
  | DECIMAL_NEGATIVE	{
	$$ = $1;
    }
  | DOUBLE_NEGATIVE	{
	$$ = $1;
    }
;

BooleanLiteral:
    IT_true	{
	$$ = $1;
    }
  | IT_false	{
	$$ = $1;
    }
;

String:
    STRING_LITERAL1	{
	$$ = $1;
    }
  | STRING_LITERAL2	{
	$$ = $1;
    }
  | STRING_LITERAL_LONG1	{
	$$ = $1;
    }
  | STRING_LITERAL_LONG2	{
	$$ = $1;
    }
;

IRIref:
    IRI_REF	{
	$$ = $1;
    }
  | PrefixedName	{
	$$ = $1;
    }
;

PrefixedName:
    PNAME_LN	{
	$$ = $1;
    }
  | PNAME_NS	{
	$$ = $1;
    }
;

BlankNode:
    BLANK_NODE_LABEL	{
	$$ = $1;
    }
  | ANON	{
	$$ = $1;
    }
;

/*** END MapSet - Change the grammar rules above ***/

%% /*** Additional Code ***/

void w3c_sw::MapSetParser::error(const MapSetParser::location_type& l,
			    const std::string& m)
{
    driver.error(l, m);
}

/* START Driver (@@ stand-alone would allow it to be shared with other parsers */

namespace w3c_sw {

    MapSetDriver::MapSetDriver (std::string baseURI, POSFactory* posFactory) : 
	Driver(baseURI, posFactory), curGraphNameStack(), root(NULL)
{
    curSubject = curPredicate = NULL;
    neededBGP = NULL;
    bgpStack.push_back(NULL);
    curBindingClause = NULL;
    curBinding = NULL;
    curExprList = NULL;
}

    MapSetDriver::~MapSetDriver ()
{
    bgpStack.pop_back();
    assert (bgpStack.empty());
}

bool MapSetDriver::parse_stream(std::istream& in, const std::string& sname)
{
    streamname = sname;

    MapSetScanner scanner(this, &in);
    scanner.set_debug(trace_scanning);
    lexer = &scanner;

    MapSetParser parser(*this);
    parser.set_debug_level(trace_parsing);
    // !!! Clear out namespaces!
    ignorePrefixFlag = false;
    return (parser.parse());
}

} // namespace w3c_sw

/* END Driver */


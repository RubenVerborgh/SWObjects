/* $Id: SPARQLalgebraParser.ypp,v 1.3 2008-11-13 19:18:01 eric Exp $ -*- mode: c++ -*- */
/* from yacker grammar  */
/* Bison parser for SPARQL + SPARUL
 * conventions:
 *   generated production names are composed of their constituents.
 *   { $$ = $1; } elided.
 *   driver has extra state for hard-to-generate tries like  Foo Bar* => ((Foo Bar) Bar)
 */

/*** yacc/bison Declarations ***/

/* Require bison 2.3 or later */
%require "2.3"

/* add debug output code to generated parser. disable this for release
 * versions. */
%debug

/* start symbol is named "start" */
%start Top

/* write out a header file containing the token defines */
%defines

/* use newer C++ skeleton file */
%skeleton "lalr1.cc"

/* namespace to enclose parser in */
%name-prefix="w3c_sw"

/* set the parser's class identifier */
%define "parser_class_name" "SPARQLalgebraParser"

/* keep track of the current position within the input */
%locations
%initial-action
{
    // initialize the initial location object
    @$.begin.filename = @$.end.filename = &driver.streamname;
};

/* The driver is passed by reference to the parser and to the scanner. This
 * provides a simple but effective pure interface, not relying on global
 * variables. */
%parse-param { class SPARQLalgebraDriver& driver }

/* verbose error messages */
%error-verbose

// %{ //  ##bison1
%code requires { // ##bison2
/* Bison seems to test inclusion with PARSER_HEADER_H, rather than something
 * which varies by parser_class_name . Overriding with define specific to
 * this parser.
 */
#endif /* !PARSER_HEADER_H */
#ifndef SPARQLALGEBRA_PARSER_HPP
#define SPARQLALGEBRA_PARSER_HPP

#include "SWObjects.hpp"
#include "ResultSet.hpp"
#include "ParserCommon.hpp"

namespace w3c_sw {

struct ParserTableConjunction : public TableConjunction {
    ParserTableConjunction () : TableConjunction() {  }
    void insertTableOperation (const TableOperation* tableOp) {
	m_TableOperations.push_front(tableOp);
    }
};

class SPARQLalgebraScanner;

/** The Driver class brings together all components. It creates an instance of
 * the SPARQLalgebraParser and SPARQLalgebraScanner classes and connects them. Then the input stream is
 * fed into the scanner object and the parser gets it's token
 * sequence. Furthermore the driver object is available in the grammar rules as
 * a parameter. Therefore the driver class contains a reference to the
 * structure into which the parsed data is saved. */

class SPARQLalgebraDriver : public YaccDriver {
    friend class SPARQLalgebraParser;
protected:
    const TTerm* curSubject;
    const TTerm* curPredicate;
    ParserFilter* curFilter;
    // const TableOperation* curOp; // needed to make right-descending tree for e.g. TriplesBlock? ( ( GraphPatternNotTriples | Filter ) '.'? TriplesBlock? )*
    ResultSet* curResultSet;
    Result* curResult;
    VariableVector termList;
    std::vector<const TTerm*>::const_iterator curTTerm;
    ProductionVector<const Expression*>* curExprList;
    const TTerm* curGraphName;
    ProductionVector<const Expression*> filterExpressions;
    bool countStar;
    WhereClause* lastWhereClause;

    BasicGraphPattern* ensureGraphPattern ( ) {
	return curGraphName == NULL ? 
	    static_cast<BasicGraphPattern*>(new DefaultGraphPattern()) : 
	    static_cast<BasicGraphPattern*>(new NamedGraphPattern(curGraphName));
    }

    ParserFilter* saveFilter () {
	ParserFilter* ret = curFilter;
	curFilter = NULL;
	return ret;
    }

    const TableOperation* makeConjunction (const TableOperation* l, const TableOperation* r) {
	if (l != NULL) {
	    if (r != NULL) {
		TableConjunction* ret = new TableConjunction();
		ret->addTableOperation(l, unnestTree);
		ret->addTableOperation(r, unnestTree);
		return ret;
	    } else
		return l;
	}
	if (r != NULL)
	    return r;
	return NULL;
    }

    const TableOperation* makeDisjunction (const TableOperation* l, const TableOperation* r) {
	TableDisjunction* ret = new TableDisjunction();
	ret->addTableOperation(l, unnestTree);
	ret->addTableOperation(r, unnestTree);
	return ret;
    }

    /**
     * Interface to normalize the zillion ways to parse a ResultSet.
     */

    void startBindingSet () {
	curResultSet = new ResultSet(atomFactory);
	curResultSet->erase(curResultSet->begin());
    }

    void addBindingVar (const TTerm* var) {
	curResultSet->addOrderedVar(var);
	termList.push_back(var);
    }

    void startBindingRow (bool iterateBindingVars = true) {
	curResult = new Result(curResultSet);
	curResultSet->insert(curResultSet->end(), curResult);
	curTTerm = iterateBindingVars ? termList.begin() : termList.end();
    }

    void addBinding (const TTerm* variable, const TTerm* value) {
	assert (curResult != NULL);
	if (value != TTerm::Unbound)
	    curResultSet->set(curResult, variable, value, false);
    }

    void addBindingValue (const TTerm* value) {
	//    throw "!! how can i get the yylocation_stack_?";
	if (curTTerm == termList.end()) {
	    std::stringstream ss;
	    ss << "atom " << value->toString() << " binding tuple wider than BINDINGS variable list.";
	    // error(*(yylocation_stack_.begin()), ss.str().c_str());
	    throw "!! how can i get the yylocation_stack_?";
	}
	if (value != TTerm::Unbound)
	    curResultSet->set(curResult, *curTTerm, value, false);
	++curTTerm;
    }

    void addBindingVarOrValue (const TTerm* term) {
	if (curResult == NULL)
	    addBindingVar(term);
	else
	    addBindingValue(term);
    }

    Result* endBindingRow () {
	if (curTTerm != termList.end()) {
	    // error(*(yylocation_stack_.begin()), "insufficient bindings for result set row.");
	    throw "!! how can i get the yylocation_stack_?";
	}
	Result* ret = curResult;
	curResult = NULL;
	return ret;
    }

    ResultSet* endBindingSet () {
	ResultSet* ret = curResultSet;
	curResultSet = NULL;
	termList.clear();
	return ret;
    }

public:
    SPARQLalgebraDriver(std::string baseURI, AtomFactory* atomFactory);
    ~SPARQLalgebraDriver();

    const Operation* parse(IStreamContext& in);
    const Operation* parse(std::string queryStr);
    void executeSelect(IStreamContext& in, RdfDB* db, ResultSet* rs);
    void executeSelect(std::string queryStr, RdfDB* db, ResultSet* rs);


    /** Pointer to the current lexer instance, this is used to connect the
     * parser to the scanner. It is used in the yylex macro. */
    class SPARQLalgebraScanner* lexer;

    /** Reference to the object created during parsing of the SPARQL stream. */
    const Operation* root;

    /** Control attributes. */
    bool unnestTree;	/* conj(conj(A, B), C) => conj(A, B, C) */
};

} // namespace w3c_sw

// %} // ##bison1
} // ##bison2

 /*** BEGIN SPARQLalgebra language tokens ***/

%union {
    const NumericRDFLiteral* p_NumericRDFLiteral;
    const Operation* p_Operation;
    const Delete* p_Delete;
    const Insert* p_Insert;
    OperationSet* p_OperationSet;
    struct {e_distinctness distinctness; VarSet* varSet; SolutionModifier* p_SolutionModifier;
	    std::vector<s_OrderConditionPair>* p_OrderConditions; ProductionVector<const Expression*>* p_having;
	    WhereClause* p_WhereClause;
    } p_protoSelect;
    Expression* p_Expression;
    ProductionVector<const Expression*>* p_Expressions;
    s_OrderConditionPair p_OrderConditionPair;
    std::vector<s_OrderConditionPair>* p_OrderConditions;
    ExpressionAliasList* p_ExpressionAliaseList;
    const TableOperation* p_op;
    ParserTableConjunction* p_conj;
    BasicGraphPattern* p_BasicGraphPattern; // used to accumulate triple patterns
    const TriplePattern* p_TriplePattern;
    // std::vector<TableOperation>* p_ops;
    const Variable* p_Variable;
    DatasetClause* p_DatasetClause;
    ProductionVector<const DatasetClause*>* p_DatasetClauses;
    e_ASCorDESC p_e_ASCorDESC;
    int p_int;
    e_Silence p_Silence;
    struct {const Delete* del; const Insert* ins;} p_DeleteInsert;
    const TTerm* p_TTerm;
    const URI* p_URI;
    bool p_bool;
    std::string* p_string;
    struct {const URI* uri; LANGTAG* langtag;} p_uri_or_langtag;
    e_distinctness p_distinctness;
    LANGTAG* p_LANGTAG;
    const BooleanRDFLiteral* p_BooleanRDFLiteral;
    /* Terminals */
}

%{
#include "../SPARQLalgebraScanner.hpp"
%}
%token			__EOF__	     0	"end of file"

/* Language tokens */
%token IT_base IT_prefix IT_project IT_extend IT_distinct IT_reduced IT_group IT_filter IT_order IT_ask IT_bgp IT_triple IT_join IT_sequence IT_leftjoin IT_optional IT_union IT_unit IT_reverse IT_named IT_modify IT_graph IT_substr IT_all IT_lcase IT_ucase IT_sha256 IT_round IT_path IT_seconds IT_str IT_create IT_asc IT_desc IT_floor IT_minutes IT_alt IT_bound IT_minus IT_in IT_hours IT_concat GT_AND IT_default IT_a TriplesSameSubject IT_if IT_regex GT_path_PLUS IT_add GT_GE IT_ceil IT_load GT_path_TIMES IT_separator GT_GT IT_insert IT_isnumeric IT_bnode GT_path_OPT IT_abs IT_coalesce GT_RCURLEY IT_DISTINCT IT_strlen IT_contains GT_NOT IT_isliteral IT_uri GT_NEQUAL IT_service GT_PLUS IT_MIN IT_isblank IT_drop IT_delete IT_slice IT_sha512 IT_MAX IT_SUM IT_COUNT IT_strlang GT_TIMES IT_AVG IT_table IT_strstarts IT_iri IT_sha384 IT_now IT_move IT_deletewhere IT_SAMPLE NIL IT_day IT_isuri GT_RPAREN IT_encode_for_uri IT_GROUP_CONCAT IT_tz IT_timezone IT_copy IT_exprlist IT_strdt GT_LPAREN IT_strends IT_deletedata IT_month GT_OR IT_exists GT_COMMA GT_LE IT_sameterm IT_quads IT_notoneof IT_year GT_EQUAL IT_seq GT_LT GT_LCURLEY IT_langmatches IT_insertdata IT_clear GT_DOT IT_isiri IT_silent IT__ IT_datatype IT_mod GT_MINUS GT_DIVIDE GT_DTYPE IT_lang IT_sha1 IT_uuid IT_struuid IT_md5 IT_strbefore IT_strafter IT_rand 
%token <p_BooleanRDFLiteral> IT_true IT_false
%token <p_NumericRDFLiteral> INTEGER DECIMAL DOUBLE INTEGER_POSITIVE
			     DECIMAL_POSITIVE DOUBLE_POSITIVE INTEGER_NEGATIVE
			     DECIMAL_NEGATIVE DOUBLE_NEGATIVE
%token <p_string> STRING_LITERAL1 STRING_LITERAL_LONG1
		  STRING_LITERAL2 STRING_LITERAL_LONG2
%token <p_URI> IRI_REF PNAME_NS PNAME_LN
%token <p_TTerm> BLANK_NODE_LABEL ANON POSITION
%token <p_Variable> VAR1 VAR2
%token <p_LANGTAG> LANGTAG

/* Productions */
%type <p_Operation> Top QueryUnit UpdateUnit Query PrefixOpt UsingOpt Update_Base Update_Prefix Updates Update1 Load Clear Drop Add Move Copy Create InsertData DeleteData DeleteWhere Modify
%type <p_Delete> DeleteClause
%type <p_Insert> InsertClause _QInsertClause_E_Opt
%type< p_OperationSet> _QUpdate1_E_Plus
%type <p_protoSelect> SliceOpt Slice DistinctOpt DistinctReduced ProjectOpt Project OrderOpt OrderClause HavingOpt HavingClause ExtendOpt GroupOpt GroupClause SubSelect
%type <p_OrderConditions> _QOrderCondition_E_Plus
%type <p_OrderConditionPair> OrderCondition _O_QGT_LPAREN_E_S_QIT_asc_E_Or_QIT_desc_E_S_QExpression_E_S_QGT_RPAREN_E_C
%type <p_ExpressionAliaseList> _QVar_E_Star
%type <p_op> AskQuery WhereClause GroupGraphPatternNoSub Filter OptionalGraphPattern GraphGraphPattern ServiceGraphPattern MinusGraphPattern GroupOrUnionGraphPattern GroupGraphPatternSub QuadData QuadPattern Quads _O_QQuadsNotTriples_E_Or_QTriplesTemplate_E_C QuadsNotTriples TriplesTemplate
%type <p_conj> _QGroupGraphPatternNoSub_E_Plus _Q_O_QQuadsNotTriples_E_Or_QTriplesTemplate_E_C_E_Star _QGroupGraphPatternSub_E_Plus
%type <p_BasicGraphPattern> _QMyTriple_E_Plus
%type <p_TriplePattern> MyTriple
%type <p_Variable> Var
%type <p_DatasetClauses> _QUsingClause_E_Plus _QUsingClause_E_Star
%type <p_DatasetClause> UsingClause
%type <p_e_ASCorDESC> _O_QIT_asc_E_Or_QIT_desc_E_C
%type <p_Silence> _QIT_silent_E_Opt
%type <p_DeleteInsert> _O_QDeleteClause_E_S_QInsertClause_E_Opt_Or_QInsertClause_E_C
%type <p_TTerm> VarOrIRIref VarOrTerm Path PathAlternative PathSequence PathEltOrInverse PathPrimary PathMod PathOneInPropertySet _QPath_E_Plus GraphTerm RDFLiteral BlankNode
%type <p_NumericRDFLiteral> Integer NumericLiteral NumericLiteralUnsigned NumericLiteralPositive NumericLiteralNegative
%type <p_BooleanRDFLiteral> BooleanLiteral

%type <p_URI> _QGraphRef_E_Opt GraphRef IRIref GraphRefAll GraphOrDefault PrefixedName _O_QIT_SUM_E_Or_QIT_MIN_E_Or_QIT_MAX_E_Or_QIT_AVG_E_Or_QIT_SAMPLE_E_C _O_QGT_DTYPE_E_S_QIRIref_E_C
%type <p_int> _O_QInteger_E_Or_QIT___E_C
%type <p_Expression> Expression _O_QGT_COMMA_E_S_QExpression_E_C ConditionalOrExpression ConditionalAndExpression RelativeExpression NumericExpression MultiplicativeExpression UnaryExpression PrimaryExpression BuiltInCall _QExpression_E_Opt RegexExpression _Q_O_QGT_COMMA_E_S_QExpression_E_C_E_Opt SubstringExpression ExistsFunc Count AdditiveExpression _O_QGT_TIMES_E_Or_QExpression_E_C MiscAgg GroupConcat IRIrefOrFunction ValueLogical RelationalExpression
%type <p_Expressions> ExprList _QExpression_E_Plus _QExprList_E_Opt _Q_O_QGT_COMMA_E_S_QExpression_E_C_E_Star ExpressionList
%type <p_distinctness>_QIT_DISTINCT_E_Opt
%type <p_string> String
%type <p_uri_or_langtag> _O_QLANGTAG_E_Or_QGT_DTYPE_E_S_QIRIref_E_C
			 _Q_O_QLANGTAG_E_Or_QGT_DTYPE_E_S_QIRIref_E_C_E_Opt

//%type <p_Expression> 

/* END TokenBlock */

//%destructor { delete $$; } BlankNode

 /*** END SPARQLalgebra - Change the grammar's tokens above ***/

%{
#include <stdarg.h>
#include "SPARQLalgebraScanner.hpp"

/* this "connects" the bison parser in the driver to the flex scanner class
 * object. it defines the yylex() function call to pull the next token from the
 * current lexer object of the driver context. */
#undef yylex
#define yylex driver.lexer->lex
%}

%% /*** Grammar Rules ***/

 /*** BEGIN SPARQLalgebra - Change the grammar rules below ***/
/* Location: http://www.w3.org//2011/09/SparqlAlgebra/SPARQL11Grammar */

Top:
    QueryUnit	{
	driver.root = $$ = $1;
    }
  | UpdateUnit	{
	driver.root = $$ = $1;
    }
;

QueryUnit:
    Query	
;

Query:
    GT_LPAREN BaseDecl PrefixOpt GT_RPAREN	{
	$$ = $3;
    }
  | PrefixOpt	
;

PrefixOpt:
    GT_LPAREN PrefixDecl UsingOpt GT_RPAREN	{
	$$ = $3;
    }
  | UsingOpt	
;

UsingOpt:
    GT_LPAREN _QUsingClause_E_Plus SliceOpt GT_RPAREN	{
	$$ = new Select($3.distinctness, $3.varSet, $2, $3.p_WhereClause, $3.p_SolutionModifier);
    }
  | GT_LPAREN _QUsingClause_E_Plus AskQuery GT_RPAREN	{
	$$ = new Ask($2, new WhereClause($3));
    }
  | AskQuery	{
	$$ = new Ask(new ProductionVector<const DatasetClause*>(), new WhereClause($1));
    }
  | SliceOpt	{
	$$ = new Select($1.distinctness, $1.varSet, new ProductionVector<const DatasetClause*>(), $1.p_WhereClause, $1.p_SolutionModifier);
    }
;

_QUsingClause_E_Plus:
    UsingClause	{
	$$ = new ProductionVector<const DatasetClause*>($1);
    }
  | _QUsingClause_E_Plus UsingClause	{
	$1->push_back($2);
	$$ = $1;
    }
;

SliceOpt:
    Slice	
  | DistinctOpt	{
	$$ = $1;
	$$.p_SolutionModifier = new SolutionModifier(NULL, NULL, NULL, -1, -1);
    }
;

DistinctOpt:
    DistinctReduced	
  | ProjectOpt	{
	$$ = $1;
	$$.distinctness = DIST_all;
    }
;

ProjectOpt:
    Project	
  | OrderOpt	{
	$$ = $1;
	$$.varSet = new StarVarSet();
    }
;

OrderOpt:
    OrderClause	
  | HavingOpt	{
	$$ = $1;
	$$.p_OrderConditions = NULL;
    }
;

HavingOpt:
    HavingClause	
  | ExtendOpt	{
	$$ = $1;
	$$.p_having = NULL;
    }
;

ExtendOpt:
    GT_LPAREN Extend GroupOpt GT_RPAREN	{
	throw std::string("ExtendOpt: not ready to parse aggregates");
	$$ = $3;
    }
  | GroupOpt	{
	$$ = $1;
    }
;

GroupOpt:
    GroupClause	
  | WhereClause	{
	$$.p_WhereClause = new WhereClause($1);
    }
;

/* [0]     Query                      ::= ( SelectQuery | ConstructQuery | DescribeQuery | AskQuery ) BindingsClause? */

AskQuery:
    GT_LPAREN IT_ask WhereClause GT_RPAREN	{
	$$ = $3;
    }
;

BaseDecl:
    IT_base IRI_REF	{
	driver.setBase($2->getLexicalValue());
    }
;

PrefixDecl:
    IT_prefix GT_LPAREN _Q_O_QGT_LPAREN_E_S_QPNAME_NS_E_S_QIRI_REF_E_S_QGT_RPAREN_E_C_E_Star GT_RPAREN	
;

_O_QGT_LPAREN_E_S_QPNAME_NS_E_S_QIRI_REF_E_S_QGT_RPAREN_E_C:
    GT_LPAREN {
	driver.ignorePrefix(true);
      } PNAME_NS {
	  driver.ignorePrefix(false);
      } IRI_REF GT_RPAREN	{
	  std::string prefix($3->getLexicalValue());
	  driver.addPrefix(prefix.substr(0, prefix.length()-1), $5);
      }
;

_Q_O_QGT_LPAREN_E_S_QPNAME_NS_E_S_QIRI_REF_E_S_QGT_RPAREN_E_C_E_Star:
    
    | _Q_O_QGT_LPAREN_E_S_QPNAME_NS_E_S_QIRI_REF_E_S_QGT_RPAREN_E_C_E_Star _O_QGT_LPAREN_E_S_QPNAME_NS_E_S_QIRI_REF_E_S_QGT_RPAREN_E_C	
;

Project:
    GT_LPAREN IT_project GT_LPAREN _QVar_E_Star GT_RPAREN OrderOpt GT_RPAREN	{
	$$ = $6;
	$$.varSet = $4;
    }
;

_QVar_E_Star:
    {
	$$ = new ExpressionAliasList();
    }
  | _QVar_E_Star Var	{
	$1->push_back(new ExpressionAlias(new TTermExpression($2)));
	$$ = $1;
    }
;

Extend:
    IT_extend GT_LPAREN _QBinding_E_Star GT_RPAREN	{
	throw std::string("Extend: not ready to parse aggregates");
    }
;

_QBinding_E_Star:
    
  | _QBinding_E_Star Binding	
;

Binding:
    GT_LPAREN Var Expression GT_RPAREN	
;

GroupExpression:
    GT_LPAREN POSITION Expression GT_RPAREN	
;

ProjectExpression:
    GT_LPAREN POSITION Aggregate GT_RPAREN	
;

/*[0]     SelectQuery                ::= SelectClause DatasetClause* WhereClause SolutionModifier */

SubSelect:
    Slice	
  | DistinctReduced	
  | Project	
  | OrderClause	
  | HavingClause	
;

DistinctReduced:
    GT_LPAREN IT_distinct ProjectOpt GT_RPAREN	{
	$$ = $3;
	$$.distinctness = DIST_distinct;
    }
  | GT_LPAREN IT_reduced ProjectOpt GT_RPAREN	{
	$$ = $3;
	$$.distinctness = DIST_reduced;
    }
;

/*[0]     SelectClause               ::= 'SELECT' ( 'DISTINCT' | 'REDUCED' )? ( ( Var | ( '(' Expression 'AS' Var ')' ) )+ | '*' ) */


/*[0]     ConstructQuery             ::= 'CONSTRUCT' ConstructTemplate DatasetClause* WhereClause SolutionModifier */


/*[0]     DescribeQuery              ::= 'DESCRIBE' ( VarOrIRIref+ | '*' ) DatasetClause* WhereClause? SolutionModifier */


/*[0]     AskQuery                   ::= 'ASK' DatasetClause* WhereClause */


/*[0]     DatasetClause              ::= 'FROM' ( DefaultGraphClause | NamedGraphClause ) */


/*[0]     DefaultGraphClause         ::= SourceSelector */


/*[0]     NamedGraphClause           ::= 'NAMED' SourceSelector */


/*[0]     SourceSelector             ::= IRIref */

WhereClause:
    GroupGraphPatternNoSub	
;

/*[0]     SolutionModifier           ::= GroupClause? HavingClause? OrderClause? LimitOffsetClauses? */

GroupClause:
    GT_LPAREN IT_group GT_LPAREN _QGroupExpression_E_Plus GT_RPAREN GT_LPAREN _QProjectExpression_E_Plus GT_RPAREN WhereClause GT_RPAREN	{
	throw std::string("GroupClause: not ready to parse aggregates");
	$$.p_WhereClause = new WhereClause($9);
    }
;

_QGroupExpression_E_Plus:
    GroupExpression	
  | _QGroupExpression_E_Plus GroupExpression	
;

_QProjectExpression_E_Plus:
    ProjectExpression	
  | _QProjectExpression_E_Plus ProjectExpression	
;

/*[0]     GroupCondition             ::= BuiltInCall | FunctionCall | '(' Expression ( 'AS' Var )? ')' | Var */

HavingClause:
    GT_LPAREN IT_filter Expression ExtendOpt GT_RPAREN	{
	$$ = $4;
	$$.p_having = new w3c_sw::ProductionVector<const w3c_sw::Expression*>($3); // !!!
    }
;

/*[0]     HavingCondition            ::= Constraint */

OrderClause:
    GT_LPAREN IT_order GT_LPAREN _QOrderCondition_E_Plus GT_RPAREN HavingOpt GT_RPAREN	{
	$$ = $6;
	$$.p_OrderConditions = $4;
    }
;

_QOrderCondition_E_Plus:
    OrderCondition	{
	$$ = new std::vector<s_OrderConditionPair>();
	$$->push_back($1);
    }
  | _QOrderCondition_E_Plus OrderCondition	{
	$1->push_back($2);
	$$ = $1;
    }
;

OrderCondition:
    _O_QGT_LPAREN_E_S_QIT_asc_E_Or_QIT_desc_E_S_QExpression_E_S_QGT_RPAREN_E_C	
  | Expression	{
	$$.ascOrDesc = ORDER_Asc;
	$$.expression = $1;
    }
;

_O_QIT_asc_E_Or_QIT_desc_E_C:
    IT_asc	{
	$$ = ORDER_Asc;
    }

    | IT_desc	{
	$$ = ORDER_Desc;
    }
;

_O_QGT_LPAREN_E_S_QIT_asc_E_Or_QIT_desc_E_S_QExpression_E_S_QGT_RPAREN_E_C:
    GT_LPAREN _O_QIT_asc_E_Or_QIT_desc_E_C Expression GT_RPAREN	{
	$$.ascOrDesc = $2;
	$$.expression = $3;
    }
;

Slice:
    GT_LPAREN IT_slice _O_QInteger_E_Or_QIT___E_C _O_QInteger_E_Or_QIT___E_C DistinctOpt GT_RPAREN	{
	$$ = $5; // ($5.p_group, ...)
	$$.p_SolutionModifier = new SolutionModifier(NULL, $5.p_having, $5.p_OrderConditions, $3, $4); // !!!
    }
;

_O_QInteger_E_Or_QIT___E_C:
    Integer	{
	$$ = ((IntegerRDFLiteral*)$1)->getValue();
    }
  | IT__	{
	$$ = LIMIT_None;
    }
;

/*[0]     LimitOffsetClauses         ::= LimitClause OffsetClause? | OffsetClause LimitClause? */


/*[0]     LimitClause                ::= 'LIMIT' Integer */


/*[0]     OffsetClause               ::= 'OFFSET' Integer */


/*[0]     BindingsClause             ::= 'BINDINGS' Var* '{' ( '(' BindingValue+ ')' | NIL )* '}' */


/*[0]     BindingValue               ::= IRIref | RDFLiteral | NumericLiteral | BooleanLiteral | 'UNDEF' */

UpdateUnit:
    Update_Base	
;

Update_Base:
    GT_LPAREN BaseDecl Update_Prefix GT_RPAREN	{
	$$ = $3;
    }
  | Update_Prefix	
;

Update_Prefix:
    GT_LPAREN PrefixDecl Updates GT_RPAREN	{
	$$ = $3;
    }
  | Updates	
;

Updates:
    GT_LPAREN _QUpdate1_E_Plus GT_RPAREN	{
	$$ = $2;
}
;

_QUpdate1_E_Plus:
    Update1	{
	OperationSet* ret = new OperationSet();
	ret->push_back($1);
    }
  | _QUpdate1_E_Plus Update1	{
	$1->push_back($2);
	$$ = $1;
    }
;

/*[0]     Update                     ::= Prologue Update1 ( ';' Update? )? */

Update1:
    Load	
  | Clear	
  | Drop	
  | Add	
  | Move	
  | Copy	
  | Create	
  | InsertData	
  | DeleteData	
  | DeleteWhere	
  | Modify	
;

Load:
    GT_LPAREN IT_load IRIref _QGraphRef_E_Opt GT_RPAREN	{
	$$ = new Load($3, $4);
    }
;

_QGraphRef_E_Opt:
    {
	$$ = NULL;
    }
  | GraphRef	
;

/*[0]     Load                       ::= 'LOAD' IRIref ( 'INTO' GraphRef )? */

Clear:
    GT_LPAREN IT_clear _QIT_silent_E_Opt GraphRefAll GT_RPAREN	{
	$$ = new Clear($3, $4);
    }
;

_QIT_silent_E_Opt:
    {
	$$ = SILENT_No;
    }
  | IT_silent	{
	$$ = SILENT_Yes;
    }
;

/*[0]     Clear                      ::= 'CLEAR' 'SILENT'? GraphRefAll */

Drop:
    GT_LPAREN IT_drop _QIT_silent_E_Opt GraphRefAll GT_RPAREN	{
	$$ = new Drop($3, $4);
    }
;

/*[0]     Drop                       ::= 'DROP' 'SILENT'? GraphRefAll */

Create:
    GT_LPAREN IT_create _QIT_silent_E_Opt GraphRef GT_RPAREN	{
	$$ = new Create($3, $4);
    }
;

/*[0]     Create                     ::= 'CREATE' 'SILENT'? GraphRef */

Add:
    GT_LPAREN IT_add _QIT_silent_E_Opt GraphOrDefault GraphOrDefault GT_RPAREN	{
	$$ = new Add($3, $4, $5);
    }
;

/*[0]     Add                        ::= 'ADD' 'SILENT'? GraphOrDefault 'TO' GraphOrDefault */

Move:
    GT_LPAREN IT_move _QIT_silent_E_Opt GraphOrDefault GraphOrDefault GT_RPAREN	{
	$$ = new Move($3, $4, $5);
    }
;

/*[0]     Move                       ::= 'MOVE' 'SILENT'? GraphOrDefault 'TO' GraphOrDefault */

Copy:
    GT_LPAREN IT_copy _QIT_silent_E_Opt GraphOrDefault GraphOrDefault GT_RPAREN	{
	$$ = new Copy($3, $4, $5);
    }
;

/*[0]     Copy                       ::= 'COPY' 'SILENT'? GraphOrDefault 'TO' GraphOrDefault */

InsertData:
    GT_LPAREN IT_insertdata QuadData GT_RPAREN	{
	$$ = new Insert($3, NULL);
    }
;

/*[0]     InsertData                 ::= 'INSERT[ \t\r\n]+DATA' QuadData */

DeleteData:
    GT_LPAREN IT_deletedata QuadData GT_RPAREN	{
	$$ = new Delete($3, NULL);
    }
;

/*[0]     DeleteData                 ::= 'DELETE[ \t\r\n]+DATA' QuadData */

DeleteWhere:
    GT_LPAREN IT_deletewhere QuadPattern GT_RPAREN	{
	$$ = new Delete($3, NULL);
    }
;

/*[0]     DeleteWhere                ::= 'DELETE[ \t\r\n]+WHERE' QuadPattern */

Modify:
    GT_LPAREN IT_modify _QUsingClause_E_Star GroupGraphPatternNoSub _O_QDeleteClause_E_S_QInsertClause_E_Opt_Or_QInsertClause_E_C GT_RPAREN	{
	$$ = new Modify($5.del, $5.ins, new WhereClause($4));
    }
;

_QUsingClause_E_Star:
    {
	$$ = new ProductionVector<const DatasetClause*>();
    }
  | _QUsingClause_E_Star UsingClause	{
	$1->push_back($2);
	$$ = $1;
    }
;

_QInsertClause_E_Opt:
    {
	$$ = NULL;
    }
  | InsertClause	
;

_O_QDeleteClause_E_S_QInsertClause_E_Opt_Or_QInsertClause_E_C:
    DeleteClause _QInsertClause_E_Opt	{
	$$.del = $1;
	$$.ins = $2;
    }
  | InsertClause	{
	$$.del = NULL;
	$$.ins = $1;
    }
;

/*[0]     Modify                     ::= ( 'WITH' IRIref )? ( DeleteClause InsertClause? | InsertClause ) UsingClause* 'WHERE' GroupGraphPatternNoSub */

DeleteClause:
    GT_LPAREN IT_delete QuadPattern GT_RPAREN	{
	$$ = new Delete($3, NULL);
    }
;

/*[0]     DeleteClause               ::= 'DELETE' QuadPattern */

InsertClause:
    GT_LPAREN IT_insert QuadPattern GT_RPAREN	{
	$$ = new Insert($3, NULL);
    }
;

/*[0]     InsertClause               ::= 'INSERT' QuadPattern */

UsingClause:
    GT_LPAREN IT_default IRIref GT_RPAREN	{
	$$ = new DefaultGraphClause($3, driver.atomFactory);
    }
  | GT_LPAREN IT_named IRIref IRIref GT_RPAREN	{
	$$ = new NamedGraphClause($3, driver.atomFactory);
    }
;

/*[0]     UsingClause                ::= 'USING' ( IRIref | 'NAMED' IRIref ) */

GraphOrDefault:
    IT__	{
	$$ = NULL;
    }
  | IRIref	
;

/*[0]     GraphOrDefault             ::= 'DEFAULT' | 'GRAPH'? IRIref */

GraphRef:
    IRIref	
;

/*[0]     GraphRef                   ::= 'GRAPH' IRIref */

GraphRefAll:
    GraphRef	
  | IT_default	{
	w3c_sw_NEED_IMPL("DEFAULT");
    }
  | IT_named	{
	w3c_sw_NEED_IMPL("NAMED");
    }
  | IT_all	{
	w3c_sw_NEED_IMPL("ALL");
    }
;

/*[0]     GraphRefAll                ::= GraphRef | 'DEFAULT' | 'NAMED' | 'ALL' */

QuadPattern:
    Quads
;

QuadData:
    Quads
;

Quads:
    _Q_O_QQuadsNotTriples_E_Or_QTriplesTemplate_E_C_E_Star	{
	$$ = $1;
    }
;

_O_QQuadsNotTriples_E_Or_QTriplesTemplate_E_C:
    QuadsNotTriples	
  | TriplesTemplate	
;

_Q_O_QQuadsNotTriples_E_Or_QTriplesTemplate_E_C_E_Star:
    {
	$$ = new ParserTableConjunction();
    }
  | _Q_O_QQuadsNotTriples_E_Or_QTriplesTemplate_E_C_E_Star _O_QQuadsNotTriples_E_Or_QTriplesTemplate_E_C	{
	$1->addTableOperation($2, false);
	$$ = $1;
    }
;

QuadsNotTriples:
    IT_quads VarOrIRIref {
	$<p_TTerm>$ = driver.curGraphName;
	driver.curGraphName = $2;
      } TriplesTemplate	{
	  $$ = $4;
	  driver.curGraphName = $<p_TTerm>3;
      }
;

TriplesTemplate:
    GT_LPAREN IT_bgp _QMyTriple_E_Plus GT_RPAREN	{
	$$ = $3;
    }
  | GT_LPAREN IT_table IT_unit GT_RPAREN	{
	$$ = driver.ensureGraphPattern();
    }
;

_QMyTriple_E_Plus:
    MyTriple	{
	$$ = driver.ensureGraphPattern();
	$$->addTriplePattern($1);
    }
  | _QMyTriple_E_Plus MyTriple	{
	$1->addTriplePattern($2);
	$$ = $1;
    }
;

GroupGraphPatternNoSub:
    TriplesTemplate	
  | Filter	
  | GT_LPAREN _O_QIT_join_E_Or_QIT_sequence_E_C GroupGraphPatternSub _QGroupGraphPatternNoSub_E_Plus GT_RPAREN	{
	$4->insertTableOperation($3);
	$$ = $4;
    }
  | OptionalGraphPattern	
  | GraphGraphPattern	
  | ServiceGraphPattern	
  | MinusGraphPattern	
  | GroupOrUnionGraphPattern	
  | GT_LPAREN IT_path VarOrTerm Path VarOrTerm GT_RPAREN	{
	throw new std::string("GroupGraphPatternNoSub: GT_LPAREN IT_path VarOrTerm Path VarOrTerm GT_RPAREN not implemented");
	$$ = driver.ensureGraphPattern();
    }
;

_O_QIT_join_E_Or_QIT_sequence_E_C:
    IT_join	
  | IT_sequence	
;

_QGroupGraphPatternNoSub_E_Plus:
    GroupGraphPatternNoSub	{
	$$ = new ParserTableConjunction();
	$$->addTableOperation($1, driver.unnestTree);
    }
  | _QGroupGraphPatternNoSub_E_Plus GroupGraphPatternNoSub	{
	$1->addTableOperation($2, driver.unnestTree);
	$$ = $1;
    }
;

GroupGraphPatternSub:
    TriplesTemplate	
  | Filter	
  | GT_LPAREN _O_QIT_join_E_Or_QIT_sequence_E_C GroupGraphPatternSub _QGroupGraphPatternSub_E_Plus GT_RPAREN	{
	$4->addTableOperation($3, driver.unnestTree);
	$$ = $4;
    }
  | OptionalGraphPattern	
  | GraphGraphPattern	
  | ServiceGraphPattern	
  | MinusGraphPattern	
  | GroupOrUnionGraphPattern	
  | GT_LPAREN IT_path VarOrTerm Path VarOrTerm GT_RPAREN	{
	throw new std::string("GroupGraphPatternSub: GT_LPAREN IT_path VarOrTerm Path VarOrTerm GT_RPAREN not implemented");
	$$ = driver.ensureGraphPattern();
    }
  | SubSelect	{
	$$ = new SubSelect(new Select($1.distinctness, $1.varSet, NULL, $1.p_WhereClause, $1.p_SolutionModifier));
    }
;

_QGroupGraphPatternSub_E_Plus:
    GroupGraphPatternSub	{
	$$ = new ParserTableConjunction();
	$$->addTableOperation($1, driver.unnestTree);
    }
  | _QGroupGraphPatternSub_E_Plus GroupGraphPatternSub	{
	$1->addTableOperation($2, driver.unnestTree);
	$$ = $1;
    }
;

ExprList:
    GT_LPAREN IT_exprlist _QExpression_E_Plus GT_RPAREN	{
	$$ = $3;
    }
;

_QExpression_E_Plus:
    Expression	{
	$$ = new ProductionVector<const Expression*>($1);
    }
  | _QExpression_E_Plus Expression	{
	$1->push_back($2);
	$$ = $1;
    }
;

MyTriple:
    GT_LPAREN IT_triple VarOrTerm VarOrTerm VarOrTerm GT_RPAREN	{
	$$ = driver.atomFactory->getTriple($3, $4, $5);
    }
;

/*[0]     GroupGraphPatternSub       ::= TriplesBlock? ( GraphPatternNotTriples '.'? TriplesBlock? )* */


/*[0]     TriplesBlock               ::= TriplesSameSubjectPath ( '.' TriplesBlock? )? */


/*[0]     GraphPatternNotTriples     ::= GroupOrUnionGraphPattern | OptionalGraphPattern | MinusGraphPattern | GraphGraphPattern | ServiceGraphPattern | Filter | Bind */

OptionalGraphPattern:
    GT_LPAREN IT_leftjoin GroupGraphPatternNoSub GroupGraphPatternNoSub _QExprList_E_Opt GT_RPAREN	{
	OptionalGraphPattern* opt = new OptionalGraphPattern($4);
	TableConjunction* conj = new TableConjunction();
	conj->addTableOperation($3, driver.unnestTree);
	conj->addTableOperation(opt, driver.unnestTree);
	if ($5 != NULL) {
	    for (std::vector<const Expression*>::const_iterator it = $5->begin();
		 it != $5->end(); ++it)
		opt->addExpression(*it);
	    $5->clear();
	    delete $5;
	}
	$$ = conj;
    }
  | GT_LPAREN IT_optional GroupGraphPatternNoSub _QExprList_E_Opt GT_RPAREN	{
	OptionalGraphPattern* opt = new OptionalGraphPattern($3);
	if ($4 != NULL) {
	    for (std::vector<const Expression*>::const_iterator it = $4->begin();
		 it != $4->end(); ++it)
		opt->addExpression(*it);
	    $4->clear();
	    delete $4;
	}
	$$ = opt;
    }
;

_QExprList_E_Opt:
    {
	$$ = NULL;
    }
  | ExprList	
;

GraphGraphPattern:
    GT_LPAREN IT_graph VarOrIRIref {
	$<p_TTerm>$ = driver.curGraphName;
	driver.curGraphName = $3;
      } GroupGraphPatternNoSub GT_RPAREN	{
	  $$ = $5;
	  driver.curGraphName = $<p_TTerm>4;
      }
;

ServiceGraphPattern:
    GT_LPAREN IT_service _QIT_silent_E_Opt VarOrIRIref GroupGraphPatternNoSub GT_RPAREN	{
	$$ = new ServiceGraphPattern($4, $5, $3, driver.atomFactory, false);
    }
;

/*[0]     Bind                       ::= 'BIND' '(' Expression 'AS' Var ')' */

MinusGraphPattern:
    GT_LPAREN IT_minus GroupGraphPatternNoSub GroupGraphPatternNoSub GT_RPAREN	{
	TableConjunction* ret = new TableConjunction();
	ret->addTableOperation($3, driver.unnestTree);
	ret->addTableOperation(new MinusGraphPattern($4), driver.unnestTree);
	$$ = ret;
    }
;

GroupOrUnionGraphPattern:
    GT_LPAREN IT_union GroupGraphPatternNoSub GroupGraphPatternNoSub GT_RPAREN	{
	TableDisjunction* ret = new TableDisjunction();
	ret->addTableOperation($3, driver.unnestTree);
	ret->addTableOperation($4, driver.unnestTree);
	$$ = ret;
    }
;

Filter:
    GT_LPAREN IT_filter ExprList GroupGraphPatternNoSub GT_RPAREN	{
	$$ = new Filter($4, $3->begin(), $3->end());
	$3->clear();
	delete $3;
    }
;

/* [0]     Constraint                 ::= BrackettedExpression | BuiltInCall */


/* [0]     FunctionCall               ::= IRIref ArgList */


/* [0]     ArgList                    ::= NIL | '(' 'DISTINCT'? Expression ( ',' Expression )* ')' */

ExpressionList:
    NIL	{
	$$ = NULL;
    }
  | GT_LPAREN Expression _Q_O_QGT_COMMA_E_S_QExpression_E_C_E_Star GT_RPAREN	{
	$3->push_front($2);
	$$ = $3;
    }
;

_O_QGT_COMMA_E_S_QExpression_E_C:
    GT_COMMA Expression	{
	$$ = $2;
    }
;

_Q_O_QGT_COMMA_E_S_QExpression_E_C_E_Star:
    {
	$$ = new ProductionVector<const Expression*>();
    }
  | _Q_O_QGT_COMMA_E_S_QExpression_E_C_E_Star _O_QGT_COMMA_E_S_QExpression_E_C	{
	$1->push_back($2);
	$$ = $1;
    }
;

/*[0]     ConstructTemplate          ::= '{' ConstructTriples? '}' */


/*[0]     ConstructTriples           ::= TriplesSameSubject ( '.' ConstructTriples? )? */


/*[0]     TriplesSameSubject         ::= VarOrTerm PropertyListNotEmpty | TriplesNode PropertyList */


/*[0]     PropertyListNotEmpty       ::= Verb ObjectList ( ';' ( Verb ObjectList )? )* */


/*[0]     PropertyList               ::= PropertyListNotEmpty? */


/*[0]     ObjectList                 ::= Object ( ',' Object )* */


/*[0]     Object                     ::= GraphNode */


/*[0]     Verb                       ::= VarOrIRIref | 'a' */


/*[0]     TriplesSameSubjectPath     ::= VarOrTerm PropertyListNotEmptyPath | TriplesNode PropertyListPath */


/*[0]     PropertyListNotEmptyPath   ::= ( VerbPath | VerbSimple ) ObjectList ( ';' ( ( VerbPath | VerbSimple ) ObjectList )? )* */


/*[0]     PropertyListPath           ::= PropertyListNotEmpty? */


/*[0]     VerbPath                   ::= Path */


/*[0]     VerbSimple                 ::= Var */


/*[0]     Path                       ::= PathAlternative */

Path:
    PathAlternative	
  | PathSequence	
  | PathEltOrInverse	
  | PathMod	
  | PathOneInPropertySet	
  | PathPrimary	
;

PathAlternative:
    GT_LPAREN IT_alt Path Path GT_RPAREN	{
	// $$ = new PathAlternative($3, $4);
    }
;

PathSequence:
    GT_LPAREN IT_seq Path Path GT_RPAREN	{
	// $$ = new PathSequence($3, $4);
    }
;

/*[0]     PathElt                    ::= PathPrimary PathMod? */

PathEltOrInverse:
    GT_LPAREN IT_reverse Path GT_RPAREN	{
	// $$ = new PathEltOrInverse($3);
    }
;

PathMod:
    GT_LPAREN _O_QGT_path_OPT_E_Or_QGT_path_TIMES_E_Or_QGT_path_PLUS_E_C Path GT_RPAREN	{
	// $$ = $3;
    }
  | GT_LPAREN IT_mod _O_QInteger_E_Or_QIT___E_C _O_QInteger_E_Or_QIT___E_C Path GT_RPAREN	{
	// $$ = $5;
      }
;

_O_QGT_path_OPT_E_Or_QGT_path_TIMES_E_Or_QGT_path_PLUS_E_C:
    GT_path_OPT	
  | GT_path_TIMES	
  | GT_path_PLUS	
;

PathPrimary:
    IRIref	{
	$$ = $1;
    }
  | IT_a	{
	$$ = driver.getURI("http://www.w3.org/1999/02/22-rdf-syntax-ns#type");
    }
;

/*[0]     PathNegatedPropertySet     ::= ( PathOneInPropertySet | '(' ( PathOneInPropertySet ( '|' PathOneInPropertySet )* )? ')' ) */

PathOneInPropertySet:
    GT_LPAREN IT_notoneof _QPath_E_Plus GT_RPAREN	{
	$$ = $3;
    }
;

_QPath_E_Plus:
    Path	
  | _QPath_E_Plus Path	{
	// $1->push_back($2);
	$$ = $1;
    }
;

Integer:
    INTEGER	{
	$$ = $1;
    }
;

/*[0]     TriplesNode                ::= Collection | BlankNodePropertyList */


/*[0]     BlankNodePropertyList      ::= '[' PropertyListNotEmpty ']' */


/*[0]     Collection                 ::= '(' GraphNode+ ')' */


/*[0]     GraphNode                  ::= VarOrTerm | TriplesNode */

VarOrTerm:
    Var	{
	$$ = $1;
    }
  | GraphTerm	
;

VarOrIRIref:
    Var	{
	$$ = $1;
    }
  | IRIref	{
	$$ = $1;
    }
;

Var:
    VAR1	
  | VAR2	
;

GraphTerm:
    IRIref	{
	$$ = $1;
    }
  | RDFLiteral	
  | NumericLiteral	{
	$$ = $1;
    }
  | BooleanLiteral	{
	$$ = $1;
    }
  | BlankNode	
  | NIL	{
	$$ = driver.getURI("http://www.w3.org/1999/02/22-rdf-syntax-ns#nil");
    }
;

Expression:
    ConditionalOrExpression	
  | ConditionalAndExpression	
  | ValueLogical	
  | MultiplicativeExpression	
  | UnaryExpression	
  | PrimaryExpression	
;

ConditionalOrExpression:
    GT_LPAREN GT_OR Expression Expression GT_RPAREN	{
	ProductionVector<const Expression*>* t = new ProductionVector<const Expression*>();
	t->push_back($3);
	t->push_back($4);
	$$ = new BooleanDisjunction(t);
    }
;

ConditionalAndExpression:
    GT_LPAREN GT_AND Expression Expression GT_RPAREN	{
	ProductionVector<const Expression*>* t = new ProductionVector<const Expression*>();
	t->push_back($3);
	t->push_back($4);
	$$ = new BooleanConjunction(t);
    }
;

ValueLogical:
    RelationalExpression	
;

RelationalExpression:
    NumericExpression	
    | RelativeExpression	
;

RelativeExpression:
    GT_LPAREN GT_EQUAL Expression Expression GT_RPAREN	{
	$$ = new BooleanEQ($3, $4);
    }
  | GT_LPAREN GT_NEQUAL Expression Expression GT_RPAREN	{
	$$ = new BooleanNE($3, $4);
    }
  | GT_LPAREN GT_LT Expression Expression GT_RPAREN	{
	$$ = new BooleanLT($3, $4);
    }
  | GT_LPAREN GT_GT Expression Expression GT_RPAREN	{
	$$ = new BooleanGT($3, $4);
    }
  | GT_LPAREN GT_LE Expression Expression GT_RPAREN	{
	$$ = new BooleanLE($3, $4);
    }
  | GT_LPAREN GT_GE Expression Expression GT_RPAREN	{
	$$ = new BooleanGE($3, $4);
    }
  | GT_LPAREN IT_in _QExpression_E_Plus GT_RPAREN	{
	$$ = new NaryIn($3);
    }
;

/*                                     | '(' 'NOT IN' ExpressionList Expression ')' */

NumericExpression:
    AdditiveExpression	
;

AdditiveExpression:
    GT_LPAREN GT_PLUS Expression Expression GT_RPAREN	{
	ProductionVector<const Expression*>* t = new ProductionVector<const Expression*>();
	t->push_back($3);
	t->push_back($4);
	$$ = new ArithmeticSum(t);
    }
  | GT_LPAREN GT_MINUS Expression Expression GT_RPAREN	{
	ProductionVector<const Expression*>* t = new ProductionVector<const Expression*>();
	t->push_back($3);
	t->push_back(new ArithmeticNegation($4));
	$$ = new ArithmeticSum(t);
    }
;

/*| '(' NumericLiteralPositive | NumericLiteralNegative ')' */


                                     /* not needed in algebra? ( '*' UnaryExpression | '/' UnaryExpression )? */

MultiplicativeExpression:
    GT_LPAREN GT_TIMES Expression Expression GT_RPAREN	{
	ProductionVector<const Expression*>* t = new ProductionVector<const Expression*>();
	t->push_back($3);
	t->push_back(new ArithmeticNegation($4));
	$$ = new ArithmeticProduct(t);
    }
  | GT_LPAREN GT_DIVIDE Expression Expression GT_RPAREN	{
	ProductionVector<const Expression*>* t = new ProductionVector<const Expression*>();
	t->push_back($3);
	t->push_back(new ArithmeticInverse($4));
	$$ = new ArithmeticProduct(t);
    }
;

UnaryExpression:
    GT_LPAREN GT_NOT Expression GT_RPAREN	{
	$$ = new BooleanNegation($3);
    }
   | GT_LPAREN GT_PLUS Expression GT_RPAREN	{
	$$ = $3;
    }
  | GT_LPAREN GT_MINUS Expression GT_RPAREN	{
	$$ = new ArithmeticNegation($3);
    }
;

PrimaryExpression:
    BuiltInCall	
  | IRIrefOrFunction	
  | RDFLiteral	{
	$$ = new TTermExpression($1);
    }
  | NumericLiteral	{
	$$ = new TTermExpression($1);
    }
  | BooleanLiteral	{
	$$ = new TTermExpression($1);
    }
  | Var	{
	$$ = new TTermExpression($1);
    }
  | POSITION	{
	$$ = new TTermExpression($1);
    }
;

/*  | Aggregate */


/* [0]     BrackettedExpression       ::= '(' Expression ')' */

BuiltInCall:
    GT_LPAREN IT_str Expression GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(TTerm::FUNC_str, $3, NULL, NULL));
    }
  | GT_LPAREN IT_lang Expression GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(TTerm::FUNC_lang, $3, NULL, NULL));
    }
  | GT_LPAREN IT_langmatches Expression GT_COMMA Expression GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(TTerm::FUNC_langMatches, $3, $5, NULL));
    }
  | GT_LPAREN IT_datatype Expression GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(TTerm::FUNC_datatype, $3, NULL, NULL));
    }
  | GT_LPAREN IT_bound Var GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(TTerm::FUNC_bound, new TTermExpression($3), NULL, NULL));
    }
  | GT_LPAREN IT_iri Expression GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(TTerm::FUNC_iri, $3, NULL, NULL));
    }
  | GT_LPAREN IT_uri Expression GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(TTerm::FUNC_iri, $3, NULL, NULL));
    }
  | GT_LPAREN IT_bnode _QExpression_E_Opt GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(TTerm::FUNC_bnode, $3, NULL, NULL));
    }
  | GT_LPAREN IT_rand GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(TTerm::FUNC_rand, NULL, NULL, NULL));
    }
  | GT_LPAREN IT_abs Expression GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(TTerm::FUNC_numeric_abs, $3, NULL, NULL));
    }
  | GT_LPAREN IT_ceil Expression GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(TTerm::FUNC_numeric_ceil, $3, NULL, NULL));
    }
  | GT_LPAREN IT_floor Expression GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(TTerm::FUNC_numeric_floor, $3, NULL, NULL));
    }
  | GT_LPAREN IT_round Expression GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(TTerm::FUNC_numeric_round, $3, NULL, NULL));
    }
  | GT_LPAREN IT_concat _QExpression_E_Plus GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(TTerm::FUNC_concat, new ArgList($3)));
    }
  | SubstringExpression	
  | GT_LPAREN IT_strlen Expression GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(TTerm::FUNC_string_length, $3, NULL, NULL));
    }
  | GT_LPAREN IT_ucase Expression GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(TTerm::FUNC_upper_case, $3, NULL, NULL));
    }
  | GT_LPAREN IT_lcase Expression GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(TTerm::FUNC_lower_case, $3, NULL, NULL));
    }
  | GT_LPAREN IT_encode_for_uri Expression GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(TTerm::FUNC_encode_for_uri, $3, NULL, NULL));
    }
  | GT_LPAREN IT_contains Expression GT_COMMA Expression GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(TTerm::FUNC_contains, $3, $5, NULL));
    }
  | GT_LPAREN IT_strstarts Expression GT_COMMA Expression GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(TTerm::FUNC_starts_with, $3, $5, NULL));
    }
  | GT_LPAREN IT_strends Expression GT_COMMA Expression GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(TTerm::FUNC_ends_with, $3, $5, NULL));
    }
  | GT_LPAREN IT_strbefore Expression GT_COMMA Expression GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(TTerm::FUNC_substring_before, $3, $5, NULL));
    }
  | GT_LPAREN IT_strafter Expression GT_COMMA Expression GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(TTerm::FUNC_substring_after, $3, $5, NULL));
    }
  | GT_LPAREN IT_year Expression GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(TTerm::FUNC_year_from_dateTime, $3, NULL, NULL));
    }
  | GT_LPAREN IT_month Expression GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(TTerm::FUNC_month_from_dateTime, $3, NULL, NULL));
    }
  | GT_LPAREN IT_day Expression GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(TTerm::FUNC_day_from_dateTime, $3, NULL, NULL));
    }
  | GT_LPAREN IT_hours Expression GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(TTerm::FUNC_hours_from_dateTime, $3, NULL, NULL));
    }
  | GT_LPAREN IT_minutes Expression GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(TTerm::FUNC_minutes_from_dateTime, $3, NULL, NULL));
    }
  | GT_LPAREN IT_seconds Expression GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(TTerm::FUNC_seconds_from_dateTime, $3, NULL, NULL));
    }
  | GT_LPAREN IT_timezone Expression GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(TTerm::FUNC_timezone_from_dateTime, $3, NULL, NULL));
    }
  | GT_LPAREN IT_tz Expression GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(TTerm::FUNC_timezone_from_dateTime, $3, NULL, NULL));
    }
  | GT_LPAREN IT_now GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(TTerm::FUNC_now, NULL, NULL, NULL));
    }
  | GT_LPAREN IT_md5 Expression GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(TTerm::FUNC_md5, $3, NULL, NULL));
    }
  | GT_LPAREN IT_sha1 Expression GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(TTerm::FUNC_sha1, $3, NULL, NULL));
    }
  | GT_LPAREN IT_sha256 Expression GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(TTerm::FUNC_sha256, $3, NULL, NULL));
    }
  | GT_LPAREN IT_sha384 Expression GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(TTerm::FUNC_sha384, $3, NULL, NULL));
    }
  | GT_LPAREN IT_sha512 Expression GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(TTerm::FUNC_sha512, $3, NULL, NULL));
    }
  | GT_LPAREN IT_coalesce ExpressionList GT_RPAREN	{
	$$ = NULL; // new FunctionCallExpression(new FunctionCall(TTerm::FUNC_coalesce, $2, NULL, NULL));
	w3c_sw_NEED_IMPL("COALESCE");
    }
  | GT_LPAREN IT_if Expression GT_COMMA Expression GT_COMMA Expression GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(TTerm::FUNC_if, $3, $5, $7));
    }
  | GT_LPAREN IT_strlang Expression GT_COMMA Expression GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(TTerm::FUNC_strlang, $3, $5, NULL));
    }
  | GT_LPAREN IT_strdt Expression GT_COMMA Expression GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(TTerm::FUNC_strdt, $3, $5, NULL));
    }
  | GT_LPAREN IT_sameterm Expression GT_COMMA Expression GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(TTerm::FUNC_sameTerm, $3, $5, NULL));
    }
  | GT_LPAREN IT_isiri Expression GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(TTerm::FUNC_isIRI, $3, NULL, NULL));
    }
  | GT_LPAREN IT_isuri Expression GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(TTerm::FUNC_isIRI, $3, NULL, NULL));
    }
  | GT_LPAREN IT_isblank Expression GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(TTerm::FUNC_isBlank, $3, NULL, NULL));
    }
  | GT_LPAREN IT_isliteral Expression GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(TTerm::FUNC_isLiteral, $3, NULL, NULL));
    }
  | GT_LPAREN IT_isnumeric Expression GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(TTerm::FUNC_isNumeric, $3, NULL, NULL));
    }
  | RegexExpression	
  | ExistsFunc	
;

_QExpression_E_Opt:
    {
	$$ = NULL;
    }
  | Expression	
;

/*                                     | NotExistsFunc */

RegexExpression:
    GT_LPAREN IT_regex Expression GT_COMMA Expression _Q_O_QGT_COMMA_E_S_QExpression_E_C_E_Opt GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(TTerm::FUNC_matches, $3, $5, $6));
    }
;

_Q_O_QGT_COMMA_E_S_QExpression_E_C_E_Opt:
    {
	$$ = NULL;
    }
  | _O_QGT_COMMA_E_S_QExpression_E_C	
;

SubstringExpression:
    GT_LPAREN IT_substr Expression GT_COMMA Expression _Q_O_QGT_COMMA_E_S_QExpression_E_C_E_Opt GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall(TTerm::FUNC_substring, $3, $5, $6));
    }
;

ExistsFunc:
    GT_LPAREN IT_exists GroupGraphPatternNoSub GT_RPAREN	{
	$$ = NULL; // new FunctionCallExpression(new FunctionCall(TTerm::FUNC_exists, driver.ensureGraphPattern(), NULL, NULL));
	w3c_sw_NEED_IMPL("EXISTS");
    }
;

/*[0]     ExistsFunc                 ::= 'EXISTS' GroupGraphPatternNoSub */


/*[0]     NotExistsFunc              ::= 'NOT' 'EXISTS' GroupGraphPatternNoSub */

Aggregate:
    GT_LPAREN _O_QCount_E_Or_QMiscAgg_E_Or_QGroupConcat_E_C GT_RPAREN	
;

_O_QCount_E_Or_QMiscAgg_E_Or_QGroupConcat_E_C:
    Count	
  | MiscAgg	
  | GroupConcat	
;

Count:
    IT_COUNT _QIT_DISTINCT_E_Opt _O_QGT_TIMES_E_Or_QExpression_E_C	{
 	$$ = new FunctionCallExpression(new AggregateCall(TTerm::FUNC_count, $2, $3));
    }
;

_QIT_DISTINCT_E_Opt:
    {
	$$ = DIST_all;
    }
  | IT_DISTINCT	{
	$$ = DIST_distinct;
}
;

_O_QGT_TIMES_E_Or_QExpression_E_C:
    GT_TIMES	{
	$$ = NULL;
    }
  | Expression	
;

MiscAgg:
    _O_QIT_SUM_E_Or_QIT_MIN_E_Or_QIT_MAX_E_Or_QIT_AVG_E_Or_QIT_SAMPLE_E_C _QIT_DISTINCT_E_Opt Expression	{
	$$ = new FunctionCallExpression(new AggregateCall($1, $2, $3));
    }
;

_O_QIT_SUM_E_Or_QIT_MIN_E_Or_QIT_MAX_E_Or_QIT_AVG_E_Or_QIT_SAMPLE_E_C:
    IT_SUM	{
	$$ = TTerm::FUNC_sum;
    }
  | IT_MIN	{
	$$ = TTerm::FUNC_min;
    }
  | IT_MAX	{
	$$ = TTerm::FUNC_max;
    }
  | IT_AVG	{
	$$ = TTerm::FUNC_avg;
    }
  | IT_SAMPLE	{
	$$ = TTerm::FUNC_sample;
    }
;

GroupConcat:
    IT_GROUP_CONCAT _QIT_DISTINCT_E_Opt Expression	{
	$$ = new FunctionCallExpression(new AggregateCall(TTerm::FUNC_group_concat, $2, $3));
    }
  | IT_GROUP_CONCAT _QIT_DISTINCT_E_Opt Separator Expression	{
	$$ = new FunctionCallExpression(new AggregateCall(TTerm::FUNC_group_concat, $2, $4));
    }
;

Separator:
    GT_LPAREN IT_separator String GT_RPAREN	
;

IRIrefOrFunction:
    IRIref	{
	$$ = new TTermExpression($1);
    }
  | GT_LPAREN IRIref _QExpression_E_Plus GT_RPAREN	{
	$$ = new FunctionCallExpression(new FunctionCall($2, new ArgList($3)));
    }
;

RDFLiteral:
    String _Q_O_QLANGTAG_E_Or_QGT_DTYPE_E_S_QIRIref_E_C_E_Opt	{
	$$ = driver.getRDFLiteral(*$1, $2.uri, $2.langtag);
	delete $1;
    }
;

_O_QGT_DTYPE_E_S_QIRIref_E_C:
    GT_DTYPE IRIref	{
	$$ = $2;
    }
;

_O_QLANGTAG_E_Or_QGT_DTYPE_E_S_QIRIref_E_C:
    LANGTAG	{
	$$.uri = NULL;
	$$.langtag = $1;
    }
  | _O_QGT_DTYPE_E_S_QIRIref_E_C	{
	$$.uri = $1;
	$$.langtag = NULL;
    }
;

_Q_O_QLANGTAG_E_Or_QGT_DTYPE_E_S_QIRIref_E_C_E_Opt:
    {
	$$.uri = NULL;
	$$.langtag = NULL;
    }
  | _O_QLANGTAG_E_Or_QGT_DTYPE_E_S_QIRIref_E_C	
;

NumericLiteral:
    NumericLiteralUnsigned	
  | NumericLiteralPositive	
  | NumericLiteralNegative	
;

NumericLiteralUnsigned:
    INTEGER	
  | DECIMAL	
  | DOUBLE	
;

NumericLiteralPositive:
    INTEGER_POSITIVE	
  | DECIMAL_POSITIVE	
  | DOUBLE_POSITIVE	
;

NumericLiteralNegative:
    INTEGER_NEGATIVE	
  | DECIMAL_NEGATIVE	
  | DOUBLE_NEGATIVE	
;

BooleanLiteral:
    IT_true	
  | IT_false	
;

String:
    STRING_LITERAL1	
  | STRING_LITERAL2	
  | STRING_LITERAL_LONG1	
  | STRING_LITERAL_LONG2	
;

IRIref:
    IRI_REF	
  | PrefixedName	
;

PrefixedName:
    PNAME_LN	
  | PNAME_NS	
;

BlankNode:
    BLANK_NODE_LABEL	
  | ANON	
;

 /*** END SPARQLalgebra - Change the grammar rules above ***/

%% /*** Additional Code ***/

void w3c_sw::SPARQLalgebraParser::error(const SPARQLalgebraParser::location_type& l,
				    const std::string& constM)
{
    driver.error(l, constM);
}

/* START Driver (@@ stand-alone would allow it to be shared with other parsers */

namespace w3c_sw {

    SPARQLalgebraDriver::SPARQLalgebraDriver (std::string baseURI, AtomFactory* atomFactory) : 
	YaccDriver(baseURI, atomFactory), curSubject(NULL), curPredicate(NULL), 
	curFilter(NULL), 
	curResultSet(NULL), curResult(NULL), curExprList(NULL), 
	root(NULL), unnestTree(false)
{
}

    SPARQLalgebraDriver::~SPARQLalgebraDriver ()
{
}

const Operation* SPARQLalgebraDriver::parse (IStreamContext& in)
{
    root = NULL;
    curGraphName = NULL;
    streamname = in.nameStr;
    // clear prefixes for nth run but keep them around for e.g. serialization.
    clearPrefixes();

    SPARQLalgebraScanner scanner(this, in.p);
    scanner.set_debug(trace_scanning);
    lexer = &scanner;

    SPARQLalgebraParser parser(*this);
    parser.set_debug_level(trace_parsing);
    // !!! Clear out namespaces!
    ignorePrefixFlag = false;
    parser.parse();
    return root;
}

const Operation* SPARQLalgebraDriver::parse (std::string queryStr)
{
    IStreamContext in(queryStr.c_str(), IStreamContext::STRING);
    return parse(in);
}

void SPARQLalgebraDriver::executeSelect (IStreamContext& in, RdfDB* db, ResultSet* rs) {
    parse(in);
    root->execute(db, rs);
    delete root;
    root = NULL;
}
void SPARQLalgebraDriver::executeSelect (std::string queryStr, RdfDB* db, ResultSet* rs) {
    parse(queryStr);
    root->execute(db, rs);
    delete root;
    root = NULL;
}


} // namespace w3c_sw

/* END Driver */

